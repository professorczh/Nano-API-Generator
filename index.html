<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ Nano Generator</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23FFD700' d='M12 2C8.5 2 5.5 4.5 4.5 8c-.5 2 .5 4 2 5.5 0 1.5-1 2.5-1.5 4 0 2.5 2 4.5 4.5 4.5 1.5 0 2.5-.5 3.5-1.5.5 1.5.5 3.5 1.5 5.5 0 2-1 3.5-2.5 4-1.5.5-3.5 0-5-1.5-2-3.5-2-5 0-2 1-3.5 2.5-4.5-.5-1.5-.5-3.5-.5-5.5 0-1.5.5-2.5 1.5-3.5-.5-1-1.5-1.5-3-1.5-2 0-3.5 1-4.5 3z'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="panzoom.min.js"></script>
    <link rel="stylesheet" href="css/style.css">
</head>
<body class="bg-gray-50 min-h-screen text-gray-800 overflow-hidden">

    <!-- å…¨å±ç”»å¸ƒå±‚ -->
    <div id="canvasLayer" class="fixed inset-0 z-0">
        <div id="canvasViewport" class="w-full h-full">
            <div id="canvas" class="absolute origin-center transition-transform duration-75 ease-out" style="width: 10000px; height: 10000px; left: 0px; top: 0px;">
                <!-- è°ƒè¯•ç½‘æ ¼ -->
                <div id="debugGrid" class="absolute inset-0 pointer-events-none hidden">
                    <svg width="10000" height="10000" viewBox="0 0 10000 10000" xmlns="http://www.w3.org/2000/svg" id="debugGridSvg">
                    </svg>
                </div>
                <div id="responseOutput" class="whitespace-pre-wrap text-gray-700 leading-relaxed italic text-gray-400 p-4">
                    å†…å®¹å°†åœ¨æ­¤å¤„æ˜¾ç¤º...
                </div>
                <div id="imageResponseContainer">
                </div>
            </div>
        </div>
    </div>

    <!-- UIæ‚¬æµ®å±‚ -->
    <div id="uiLayer" class="fixed inset-0 z-10 pointer-events-none">
        <!-- æ ‡é¢˜ -->
        <header class="pointer-events-auto absolute top-4 left-4 flex items-center gap-3">
            <img src="logo.svg" alt="Nano Generator Logo" class="w-12 h-12">
            <h1 class="text-2xl font-bold text-gray-900">Nano Generator</h1>
        </header>

        <!-- å¯æ‹–åŠ¨çš„UIé¢æ¿ -->
        <div id="uiPanel" class="pointer-events-auto absolute top-16 right-4 w-[400px] max-w-[90vw] max-h-[calc(100vh-80px)] overflow-y-auto">
            <div class="glass-card rounded-2xl p-6 shadow-sm mb-4">
                <div class="flex items-center justify-between mb-2">
                    <label class="block text-sm font-medium text-gray-700">API Key</label>
                    <div class="flex items-center gap-2">
                        <a href="https://aistudio.google.com/api-keys" target="_blank" class="text-xs text-blue-600 hover:text-blue-700 underline">è·å– API Key</a>
                        <a href="https://ai.google.dev/gemini-api/docs/models" target="_blank" class="text-xs text-gray-500 hover:text-gray-700" title="æŸ¥çœ‹æ”¯æŒçš„æ¨¡å‹">?</a>
                        <button id="toggleApiKeyPanel" class="text-sm text-blue-600 hover:text-blue-700">æŠ˜å </button>
                    </div>
                </div>
                <div id="apiKeyPanel">
                        <div class="flex gap-3">
                            <input type="text" id="apiKeyInput" 
                                class="flex-1 p-4 rounded-xl border border-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all"
                                placeholder="è¾“å…¥ä½ çš„ API Key">
                            <button id="testApiKeyBtn" 
                                class="bg-gray-600 hover:bg-gray-700 text-white px-5 py-2.5 rounded-lg font-medium transition-colors shadow-sm flex items-center gap-2 whitespace-nowrap">
                                <span>æµ‹è¯•</span>
                                <div id="testLoader" class="hidden animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full"></div>
                            </button>
                        </div>
                        <div id="apiStatus" class="mt-2 text-sm text-gray-500"></div>
                        
                        <div class="mt-3 flex gap-3">
                            <button id="saveApiKeyBtn" 
                                class="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-medium transition-colors shadow-sm text-sm">
                                å­˜å‚¨ API
                            </button>
                            <button id="clearApiKeyBtn" 
                                class="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-medium transition-colors shadow-sm text-sm">
                                æ¸…é™¤ API
                            </button>
                        </div>
                        
                        <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">
                            <div>
                                <label class="block text-xs font-medium text-gray-500 mb-1">æ–‡æœ¬æ¨¡å‹</label>
                                <select id="textModelName" 
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-500 mb-1">è¯†å›¾æ¨¡å‹</label>
                                <select id="visionModelName" 
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-500 mb-1">ç”Ÿå›¾æ¨¡å‹</label>
                                <select id="imageModelName" 
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="glass-card rounded-2xl p-6 shadow-sm">
                    <div class="flex items-center justify-between mb-2">
                        <label class="block text-sm font-medium text-gray-700">æç¤ºè¯</label>
                        <button id="togglePromptPanel" class="text-sm text-blue-600 hover:text-blue-700">æŠ˜å </button>
                    </div>
                    <div id="promptPanel">
                        <div id="promptContainer" class="w-full p-4 rounded-xl border border-gray-200 focus-within:ring-2 focus-within:ring-blue-500 focus-within:border-transparent outline-none transition-all bg-white min-h-[120px]">
                            <div id="promptInput" contenteditable="true" 
                                class="w-full border-none outline-none resize-none bg-transparent text-gray-700 placeholder-gray-400 whitespace-pre-wrap"
                                data-placeholder="è¯·è¾“å…¥æç¤ºè¯"></div>
                        </div>
                        
                        <div class="mt-4 flex justify-between items-center">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="imageGenMode" class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500" checked>
                                <span class="text-gray-700 font-medium">ç”Ÿå›¾æ¨¡å¼</span>
                            </label>
                            <div class="flex items-center gap-3">
                                <span id="statusTag" class="text-xs px-2 py-1 rounded bg-gray-50 text-gray-600">å°±ç»ª</span>
                                <button id="sendBtn" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2.5 rounded-lg font-medium transition-colors shadow-sm flex items-center gap-2">
                                    <span>å‘é€</span>
                                    <div id="loader" class="hidden animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full"></div>
                                </button>
                            </div>
                        </div>

                        <div id="imageGenOptions" class="mt-4">
                            <div class="border-t border-gray-200 pt-4">
                                <h3 class="text-sm font-semibold text-gray-700 mb-3">ç”Ÿå›¾å‚æ•°è®¾ç½®</h3>
                                
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">å®½é«˜æ¯”</label>
                                        <select id="aspectRatio"
                                            class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                            <option value="1:1" selected>1:1 æ­£æ–¹å½¢</option>
                                            <option value="16:9">16:9 å®½å±</option>
                                            <option value="9:16">9:16 ç«–å±</option>
                                            <option value="21:9">21:9 è¶…å®½å±</option>
                                            <option value="4:3">4:3 ä¼ ç»Ÿæ¨ªå‘</option>
                                            <option value="3:4">3:4 ä¼ ç»Ÿç«–å‘</option>
                                            <option value="3:2">3:2 ç»å…¸æ¨ªå‘</option>
                                            <option value="2:3">2:3 ç»å…¸ç«–å‘</option>
                                            <option value="5:4">5:4 å¤§ç”»å¹…æ¨ªå‘</option>
                                            <option value="4:5">4:5 å¤§ç”»å¹…ç«–å‘</option>
                                        </select>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">åˆ†è¾¨ç‡</label>
                                        <select id="imageSize" 
                                            class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                            <option value="1K" selected>1K (1024px)</option>
                                            <option value="2K">2K é«˜æ¸…</option>
                                            <option value="4K">4K è¶…é«˜æ¸…</option>
                                        </select>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                            æ¸©åº¦: <span id="temperatureValue">0.6</span>
                                        </label>
                                        <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.6" 
                                            class="w-full">
                                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                                            <span>ç¡®å®šæ€§</span>
                                            <span>åˆ›é€ æ€§</span>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                            Top-P: <span id="topPValue">0.95</span>
                                        </label>
                                        <input type="range" id="topP" min="0" max="1" step="0.05" value="0.95" 
                                            class="w-full">
                                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                                            <span>é›†ä¸­</span>
                                            <span>å¤šæ ·</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- è°ƒè¯•æ§åˆ¶å° -->
        <div id="debugConsole" class="debug-console collapsed pointer-events-auto">
            <div class="debug-console-header">
                <span class="debug-console-title">è°ƒè¯•æ§åˆ¶å°é¢æ¿</span>
                <span class="debug-console-toggle">â–¼</span>
            </div>
            <div class="debug-console-content" id="debugConsoleContent">
            </div>
            <div class="debug-console-footer">
                <div class="debug-console-footer-left">
                    <label class="debug-console-mouse-label">
                        <input type="checkbox" id="debugConsoleToggleMouse" class="debug-console-mouse-checkbox">
                        <span>æ˜¾ç¤ºé¼ æ ‡æ—¥å¿—</span>
                    </label>
                </div>
                <div class="debug-console-footer-right">
                    <button class="debug-console-clear" id="debugConsoleClear">æ¸…ç©º</button>
                    <label class="debug-console-mouse-label">
                        <input type="checkbox" id="debugConsoleToggleMarker" class="debug-console-mouse-checkbox">
                        <span>ä¸­å¿ƒæ ‡è®°</span>
                    </label>
                    <label class="debug-console-mouse-label">
                        <input type="checkbox" id="debugConsoleToggleCoords" class="debug-console-mouse-checkbox">
                        <span>å›¾ç‰‡åæ ‡</span>
                    </label>
                    <label class="debug-console-mouse-label">
                        <input type="checkbox" id="debugConsoleToggleGrid" class="debug-console-mouse-checkbox">
                        <span>è°ƒè¯•ç½‘æ ¼</span>
                    </label>
                    <label class="debug-console-mouse-label">
                        <input type="checkbox" id="debugConsoleToggleSample" class="debug-console-mouse-checkbox">
                        <span>æ ·ä¾‹å›¾ç‰‡</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- ç”»å¸ƒç¼©ç•¥å›¾ -->
        <div id="canvasMinimap" class="fixed bottom-32 left-4 z-20 pointer-events-auto">
            <div class="minimap-container">
                <div class="minimap-header">
                    <span class="minimap-title">ç”»å¸ƒå¯¼èˆª</span>
                </div>
                <div id="minimapContent" class="minimap-content">
                    <div id="minimapCanvas" class="minimap-canvas">
                        <div id="minimapViewport" class="minimap-viewport"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ç”»å¸ƒç¼©æ”¾æ§åˆ¶ -->
        <div id="canvasZoomControl" class="fixed bottom-96 left-4 z-20 pointer-events-auto">
            <div class="minimap-container">
                <div class="minimap-header">
                    <span class="minimap-title">ç”»å¸ƒç¼©æ”¾</span>
                </div>
                <div class="zoom-control-content">
                    <div class="zoom-buttons">
                        <button id="zoomOutBtn" class="zoom-btn" title="ç¼©å° (Ctrl+-)">âˆ’</button>
                        <div class="zoom-slider-container">
                            <input type="range" id="zoomSlider" class="zoom-slider" min="50" max="250" step="25" value="100">
                        </div>
                        <span id="zoomValue" class="zoom-value" title="ç‚¹å‡»é‡ç½®ä¸º100%">100%</span>
                        <button id="zoomInBtn" class="zoom-btn" title="æ”¾å¤§ (Ctrl+=)">+</button>
                        <button id="zoomResetBtn" class="zoom-btn" title="é‡ç½®ç¼©æ”¾">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                <path d="M3 3v5h5"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- è¿·ä½ å·¥å…·æ  -->
        <div id="miniToolbar" class="fixed bottom-16 left-1/2 transform -translate-x-1/2 z-20 pointer-events-auto">
            <button id="uploadImageBtn" class="toolbar-upload-btn">
                <svg class="toolbar-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
            </button>
            <input type="file" id="imageUploadInput" accept="image/*" class="hidden">
        </div>
        
        <!-- ç”»å¸ƒä¸­å¿ƒæ ‡è®° -->
        <div id="canvasCenterMarker" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-30 pointer-events-none">
            <div class="w-2 h-2 bg-red-500 rounded-full"></div>
            <div class="text-xs text-red-500 mt-2 whitespace-nowrap">ä¸­å¿ƒåæ ‡: è®¡ç®—ä¸­...</div>
        </div>
    </div>

    <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-90 hidden items-center justify-center z-[1000] p-4">
        <div class="bg-white rounded-2xl p-6 max-w-[95vw] max-h-[95vh] w-full shadow-2xl flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-lg font-semibold text-gray-900">å›¾ç‰‡é¢„è§ˆ</h3>
                <button id="closeModalBtn" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
            </div>
            <div class="flex justify-center mb-6 flex-grow overflow-auto">
                <img id="modalImage" class="max-w-full max-h-[75vh] rounded-lg object-contain" alt="é¢„è§ˆå›¾ç‰‡">
            </div>
            <div class="flex justify-end gap-3 flex-shrink-0">
                <button id="openFolderBtn" class="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">æ‰“å¼€æ–‡ä»¶å¤¹</button>
                <button id="closeModalBtn2" class="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">å…³é—­</button>
                <button id="downloadModalBtn" class="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors">ä¸‹è½½</button>
            </div>
        </div>
    </div>

    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-[1100] p-4">
        <div class="bg-white rounded-2xl p-6 max-w-md w-full shadow-2xl">
            <div class="flex items-center mb-4">
                <div class="w-10 h-10 bg-red-100 rounded-full flex items-center justify-center mr-3">
                    <span class="text-red-600 text-xl">âš ï¸</span>
                </div>
                <h3 class="text-lg font-semibold text-gray-900">ç¡®è®¤åˆ é™¤</h3>
            </div>
            <p class="text-gray-600 mb-4" id="confirmModalMessage">ç¡®å®šè¦åˆ é™¤è¿™å¼ å›¾ç‰‡å—ï¼Ÿ</p>
            <div class="flex items-center mb-6">
                <input type="checkbox" id="confirmModalCheckbox" class="w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                <label for="confirmModalCheckbox" class="ml-2 text-sm text-gray-600">ä¸å†æé†’</label>
            </div>
            <div class="flex justify-end gap-3">
                <button id="confirmModalCancel" class="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">å–æ¶ˆ</button>
                <button id="confirmModalOk" class="px-4 py-2 rounded-lg bg-red-600 text-white hover:bg-red-700 transition-colors">åˆ é™¤</button>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai"
      }
    }
    </script>
    
    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";
        import { CONFIG, TEXT_MODELS, IMAGE_MODELS } from "./config.js";

        const sendBtn = document.getElementById('sendBtn');
        const promptInput = document.getElementById('promptInput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const responseOutput = document.getElementById('responseOutput');
        const loader = document.getElementById('loader');
        const statusTag = document.getElementById('statusTag');
        const testApiKeyBtn = document.getElementById('testApiKeyBtn');
        const testLoader = document.getElementById('testLoader');
        const apiStatus = document.getElementById('apiStatus');
        const imageGenMode = document.getElementById('imageGenMode');
        const imageGenOptions = document.getElementById('imageGenOptions');
        const aspectRatio = document.getElementById('aspectRatio');
        const imageSize = document.getElementById('imageSize');
        const temperature = document.getElementById('temperature');
        const topP = document.getElementById('topP');
        const temperatureValue = document.getElementById('temperatureValue');
        const topPValue = document.getElementById('topPValue');
        const imageResponseContainer = document.getElementById('imageResponseContainer');
        const textModelName = document.getElementById('textModelName');
        const visionModelName = document.getElementById('visionModelName');
        const imageModelName = document.getElementById('imageModelName');
        const imageModal = document.getElementById('imageModal');
        
        let activeRequests = 0;
        const modalImage = document.getElementById('modalImage');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const closeModalBtn2 = document.getElementById('closeModalBtn2');
        const downloadModalBtn = document.getElementById('downloadModalBtn');
        const openFolderBtn = document.getElementById('openFolderBtn');
        const toggleApiKeyPanel = document.getElementById('toggleApiKeyPanel');
        const togglePromptPanel = document.getElementById('togglePromptPanel');
        const apiKeyPanel = document.getElementById('apiKeyPanel');
        const promptPanel = document.getElementById('promptPanel');
        const canvasViewport = document.getElementById('canvasViewport');
        const canvas = document.getElementById('canvas');
        const resetCanvasBtn = document.getElementById('resetCanvasBtn');
        const debugConsole = document.getElementById('debugConsole');
        const debugConsoleContent = document.getElementById('debugConsoleContent');
        const debugConsoleClear = document.getElementById('debugConsoleClear');
        const debugConsoleHeader = document.querySelector('.debug-console-header');
        const uiPanel = document.getElementById('uiPanel');
        const canvasMinimap = document.getElementById('canvasMinimap');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapViewport = document.getElementById('minimapViewport');
        const uploadImageBtn = document.getElementById('uploadImageBtn');
        const imageUploadInput = document.getElementById('imageUploadInput');
        const canvasZoomControl = document.getElementById('canvasZoomControl');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        
        let showMouseLogs = false;
        let currentBlobUrl = null;
        let panzoom = null;
        let selectedNode = null;
        let nodeCounter = 0;
        let pinCounter = 0;
        let imagePins = new Map();
        let isDraggingUIPanel = false;
        let uiPanelStartX = 0;
        let uiPanelStartY = 0;
        let uiPanelStartLeft = 0;
        let uiPanelStartTop = 0;
        let isDraggingMinimapViewport = false;
        let minimapDragStartX = 0;
        let minimapDragStartY = 0;
        let minimapPanStartX = 0;
        let minimapPanStartY = 0;
        // åº”ç”¨çŠ¶æ€ç®¡ç†
        const AppState = {
            mode: 'VIEW', // VIEW, DRAGGING_NODE, SELECTING_AREA
            activeNode: null,
            scale: 1,
            isDraggingNode: false,
            dragNode: null,
            dragStartX: 0,
            dragStartY: 0,
            dragNodeStartLeft: 0,
            dragNodeStartTop: 0,
            isMiddleMouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            panX: 0,
            panY: 0,
            isResizingNode: false,
            resizeStart: { x: 0, y: 0, width: 0, height: 0 },
            resizeNode: null,
            // ä½¿ç”¨ Map å­˜å‚¨èŠ‚ç‚¹æ•°æ®ï¼Œæ–¹ä¾¿åæœŸåŒæ­¥åˆ°åç«¯
            nodes: new Map(),
            
            // æ›´æ–°ç¼©æ”¾æ¯”ä¾‹
            updateScale: function(newScale) {
                this.scale = newScale;
                if (showMouseLogs) {
                    debugLog(`[çŠ¶æ€æ›´æ–°] ç¼©æ”¾æ¯”ä¾‹: ${newScale}`, 'info');
                }
            },
            
            // é‡ç½®çŠ¶æ€
            reset: function() {
                this.mode = 'VIEW';
                this.activeNode = null;
                this.isDraggingNode = false;
                this.dragNode = null;
                this.isMiddleMouseDown = false;
                this.isResizingNode = false;
                this.resizeNode = null;
            }
        };

        function debugLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `debug-log ${type}`;
            
            const timestamp = document.createElement('span');
            timestamp.className = 'timestamp';
            const now = new Date();
            timestamp.textContent = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.className = 'message';
            messageSpan.textContent = message;
            
            const copyIcon = document.createElement('span');
            copyIcon.className = 'debug-log-copy';
            copyIcon.innerHTML = 'ğŸ“‹';
            copyIcon.title = 'å¤åˆ¶';
            copyIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(message).then(() => {
                    copyIcon.textContent = 'âœ“';
                    setTimeout(() => {
                        copyIcon.textContent = 'ğŸ“‹';
                    }, 1000);
                });
            });
            
            logEntry.appendChild(timestamp);
            logEntry.appendChild(messageSpan);
            logEntry.appendChild(copyIcon);
            debugConsoleContent.appendChild(logEntry);
            debugConsoleContent.scrollTop = debugConsoleContent.scrollHeight;
            
            const maxLogs = 100;
            const logs = debugConsoleContent.querySelectorAll('.debug-log');
            if (logs.length > maxLogs) {
                for (let i = 0; i < logs.length - maxLogs; i++) {
                    logs[i].remove();
                }
            }
        }

        debugConsoleHeader.addEventListener('click', () => {
            debugConsole.classList.toggle('collapsed');
        });

        debugConsoleClear.addEventListener('click', (e) => {
            e.stopPropagation();
            const logs = debugConsoleContent.querySelectorAll('.debug-log');
            logs.forEach(log => log.remove());
        });

        const debugConsoleToggleMarker = document.getElementById('debugConsoleToggleMarker');
        const canvasCenterMarker = document.getElementById('canvasCenterMarker');
        
        canvasCenterMarker.classList.add('hidden');
        
        debugConsoleToggleMarker.addEventListener('change', (e) => {
            if (e.target.checked) {
                canvasCenterMarker.classList.remove('hidden');
            } else {
                canvasCenterMarker.classList.add('hidden');
            }
        });
        
        const debugConsoleToggleCoords = document.getElementById('debugConsoleToggleCoords');
        
        const allCoordsElements = document.querySelectorAll('.node-center-coords');
        allCoordsElements.forEach(element => {
            element.style.display = 'none';
        });
        
        debugConsoleToggleCoords.addEventListener('change', (e) => {
            const allCoordsElements = document.querySelectorAll('.node-center-coords');
            allCoordsElements.forEach(element => {
                if (e.target.checked) {
                    element.style.display = 'block';
                } else {
                    element.style.display = 'none';
                }
            });
        });
        
        const debugConsoleToggleGrid = document.getElementById('debugConsoleToggleGrid');
        const debugGrid = document.getElementById('debugGrid');
        
        debugGrid.classList.add('hidden');
        
        debugConsoleToggleGrid.addEventListener('change', (e) => {
            if (e.target.checked) {
                debugGrid.classList.remove('hidden');
            } else {
                debugGrid.classList.add('hidden');
            }
        });
        
        const debugConsoleToggleSample = document.getElementById('debugConsoleToggleSample');
        let sampleImageNode = null;
        
        debugConsoleToggleSample.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (!sampleImageNode) {
                    sampleImageNode = imageResponseContainer.querySelector('[data-filename="sample_image.png"]');
                    if (!sampleImageNode) {
                        addSampleImage();
                        sampleImageNode = imageResponseContainer.querySelector('[data-filename="sample_image.png"]');
                    }
                }
                if (sampleImageNode) {
                    sampleImageNode.classList.remove('hidden');
                }
            } else {
                sampleImageNode = imageResponseContainer.querySelector('[data-filename="sample_image.png"]');
                if (sampleImageNode) {
                    sampleImageNode.classList.add('hidden');
                }
            }
        });
        
        const debugConsoleToggleMouse = document.getElementById('debugConsoleToggleMouse');
        
        debugConsoleToggleMouse.addEventListener('change', (e) => {
            showMouseLogs = e.target.checked;
            debugLog(`[é¼ æ ‡æ—¥å¿—] ${showMouseLogs ? 'å¯ç”¨' : 'ç¦ç”¨'}`, 'info');
        });

        function maskApiKey(apiKey) {
            if (!apiKey || apiKey.length < 6) return apiKey;
            return apiKey.substring(0, 3) + '*'.repeat(apiKey.length - 6) + apiKey.substring(apiKey.length - 3);
        }

        function updateApiKeyDisplay() {
            const apiKey = CONFIG.API_KEY;
            if (apiKey) {
                apiKeyInput.value = maskApiKey(apiKey);
            }
        }

        apiKeyInput.value = CONFIG.API_KEY ? maskApiKey(CONFIG.API_KEY) : '';

        apiKeyInput.addEventListener('focus', () => {
            apiKeyInput.value = CONFIG.API_KEY;
        });

        apiKeyInput.addEventListener('blur', () => {
            const newValue = apiKeyInput.value.trim();
            if (newValue && newValue !== maskApiKey(CONFIG.API_KEY)) {
                CONFIG.API_KEY = newValue;
            }
            updateApiKeyDisplay();
        });

        apiKeyInput.addEventListener('input', () => {
            const newValue = apiKeyInput.value.trim();
            if (newValue && !newValue.includes('*')) {
                CONFIG.API_KEY = newValue;
            }
        });

        toggleApiKeyPanel.addEventListener('click', () => {
            if (apiKeyPanel.classList.contains('hidden')) {
                apiKeyPanel.classList.remove('hidden');
                toggleApiKeyPanel.textContent = 'æŠ˜å ';
            } else {
                apiKeyPanel.classList.add('hidden');
                toggleApiKeyPanel.textContent = 'å±•å¼€';
            }
        });

        togglePromptPanel.addEventListener('click', () => {
            if (promptPanel.classList.contains('hidden')) {
                promptPanel.classList.remove('hidden');
                togglePromptPanel.textContent = 'æŠ˜å ';
            } else {
                promptPanel.classList.add('hidden');
                togglePromptPanel.textContent = 'å±•å¼€';
            }
        });

        // UIé¢æ¿æ‹–åŠ¨åŠŸèƒ½
        uiPanel.addEventListener('mousedown', (e) => {
            const target = e.target;
            // æ’é™¤äº¤äº’å…ƒç´ ï¼šæŒ‰é’®ã€è¾“å…¥æ¡†ã€é€‰æ‹©æ¡†ã€contenteditableå…ƒç´ ã€æ»šåŠ¨æ¡
            const isInteractiveElement = target.closest('button') || 
                                       target.closest('input') || 
                                       target.closest('select') || 
                                       target.closest('textarea') ||
                                       target.closest('[contenteditable="true"]') ||
                                       target.closest('.debug-console-content');
            
            if (target.closest('.pointer-events-auto') && !isInteractiveElement) {
                isDraggingUIPanel = true;
                uiPanelStartX = e.clientX;
                uiPanelStartY = e.clientY;
                uiPanelStartLeft = parseInt(uiPanel.style.left) || parseInt(getComputedStyle(uiPanel).left);
                uiPanelStartTop = parseInt(uiPanel.style.top) || parseInt(getComputedStyle(uiPanel).top);
                uiPanel.classList.add('ui-panel-draggable');
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingUIPanel) {
                const deltaX = e.clientX - uiPanelStartX;
                const deltaY = e.clientY - uiPanelStartY;
                const newLeft = uiPanelStartLeft + deltaX;
                const newTop = uiPanelStartTop + deltaY;
                
                // é™åˆ¶é¢æ¿ä¸è¶…å‡ºå±å¹•è¾¹ç•Œ
                const maxLeft = window.innerWidth - uiPanel.offsetWidth;
                const maxTop = window.innerHeight - uiPanel.offsetHeight;
                const clampedLeft = Math.max(0, Math.min(newLeft, maxLeft));
                const clampedTop = Math.max(0, Math.min(newTop, maxTop));
                
                uiPanel.style.left = `${clampedLeft}px`;
                uiPanel.style.top = `${clampedTop}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingUIPanel) {
                isDraggingUIPanel = false;
                uiPanel.classList.remove('ui-panel-draggable');
            }
        });

        function initCanvas() {
            console.log('Initializing canvas...');
            console.log('Canvas element:', canvas);
            console.log('CanvasViewport:', canvasViewport);
            
            if (typeof Panzoom === 'undefined') {
                console.error('Panzoom library not loaded');
                return;
            }
            
            // è®¡ç®—åˆå§‹ä½ç½®ï¼Œè®©ç”»å¸ƒä¸­å¿ƒ(5000, 5000)å¯¹å‡†è§†å£ä¸­å¿ƒ
            const uiPanel = document.getElementById('uiPanel');
            const uiPanelWidth = uiPanel ? uiPanel.offsetWidth : 400;
            const viewportWidth = window.innerWidth - uiPanelWidth;
            const viewportHeight = window.innerHeight;
            const startX = viewportWidth / 2 - 5000;
            const startY = viewportHeight / 2 - 5000;
            
            panzoom = Panzoom(canvas, {
                maxScale: 2.5,
                minScale: 0.5,
                step: 0.25,
                disablePan: false,
                disableZoom: false,
                excludeClass: 'canvas-node',
                canvas: true,
                noBind: false,
                startX: startX,
                startY: startY,
                setTransform: (el, { x, y, scale }) => {
                    el.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                    
                    AppState.panX = x;
                    AppState.panY = y;
                    AppState.scale = scale;
                    
                    updateMinimapViewport();
                    updateCenterMarkerCoordinates();
                }
            });
            
            const scale = panzoom.getScale();
            AppState.updateScale(scale);
            AppState.panX = startX;
            AppState.panY = startY;
            
            // ç´§æ¥ç€æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡ UI æ›´æ–°
            setTimeout(() => {
                updateCenterMarkerCoordinates();
                updateMinimapViewport();
            }, 0);
            
            // ç”Ÿæˆè°ƒè¯•ç½‘æ ¼
            generateDebugGrid();
            
            canvasViewport.style.cursor = 'default';
            canvas.style.cursor = 'default';
            
            // ç›‘å¬ç¼©æ”¾äº‹ä»¶ï¼Œå®æ—¶æ›´æ–°çŠ¶æ€
            canvas.addEventListener('panzoomzoom', (e) => {
                const newScale = e.detail.scale;
                AppState.updateScale(newScale);
                
                // åŒæ­¥æ›´æ–°æ»‘å—å’Œç¼©æ”¾å€¼æ˜¾ç¤º
                zoomSlider.value = Math.round(newScale * 100);
                zoomValue.textContent = `${Math.round(newScale * 100)}%`;
                
                updateMinimapViewport();
                updateCenterMarkerCoordinates();
                if (!debugConsole.contains(e.target) && showMouseLogs) {
                    debugLog(`[ç¼©æ”¾äº‹ä»¶] æ–°ç¼©æ”¾æ¯”ä¾‹: ${newScale}`, 'event');
                }
            });
            
            // ç›‘å¬å¹³ç§»äº‹ä»¶ï¼Œå®æ—¶æ›´æ–°åæ ‡
            canvas.addEventListener('panzoompan', (e) => {
                const panX = e.detail.x;
                const panY = e.detail.y;
                AppState.panX = panX;
                AppState.panY = panY;
                updateMinimapViewport();
                updateCenterMarkerCoordinates();
                if (!debugConsole.contains(e.target) && showMouseLogs) {
                    debugLog(`[å¹³ç§»äº‹ä»¶] panX=${panX}, panY=${panY}`, 'event');
                }
            });
            
            canvasViewport.addEventListener('mousedown', (e) => {
                if (debugConsole.contains(e.target)) return;
                if (showMouseLogs) {
                    debugLog(`[é¼ æ ‡æŒ‰ä¸‹] ç”»å¸ƒè§†å£: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}`, 'event');
                }
                if (e.button === 1) {
                    e.preventDefault();
                    AppState.isMiddleMouseDown = true;
                    AppState.lastMouseX = e.clientX;
                    AppState.lastMouseY = e.clientY;
                    canvasViewport.style.cursor = 'grabbing';
                    if (showMouseLogs) {
                        debugLog(`[å¼€å§‹æ‹–åŠ¨] ç”»å¸ƒ: isMiddleMouseDown=${AppState.isMiddleMouseDown}`, 'info');
                    }
                } else {
                    canvasViewport.style.cursor = 'default';
                }
            });
            
            canvasViewport.addEventListener('mouseenter', () => {
                canvasViewport.style.cursor = 'default';
                canvas.style.cursor = 'default';
            });
            
            canvasViewport.addEventListener('mouseup', (e) => {
                if (showMouseLogs) {
                    debugLog(`[é¼ æ ‡é‡Šæ”¾] ç”»å¸ƒè§†å£: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}`, 'event');
                }
                if (e.button === 1) {
                    AppState.isMiddleMouseDown = false;
                    canvasViewport.style.cursor = 'default';
                    if (showMouseLogs) {
                        debugLog(`[åœæ­¢æ‹–åŠ¨] ç”»å¸ƒ: isMiddleMouseDown=${AppState.isMiddleMouseDown}`, 'info');
                    }
                }
            });
            
            canvasViewport.addEventListener('mouseleave', () => {
                AppState.isMiddleMouseDown = false;
                canvasViewport.style.cursor = '';
                canvas.style.cursor = '';
            });
            
            canvasViewport.addEventListener('contextmenu', (e) => {
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨å›¾ç‰‡èŠ‚ç‚¹ä¸Šï¼Œå¦‚æœæ˜¯åˆ™ä¸æ˜¾ç¤ºç”»å¸ƒèœå•
                const targetNode = e.target.closest('.canvas-node');
                if (targetNode) {
                    return; // è®©äº‹ä»¶ç»§ç»­ä¼ æ’­åˆ°å›¾ç‰‡èŠ‚ç‚¹çš„äº‹ä»¶ç›‘å¬å™¨
                }
                
                e.preventDefault();
                
                const existingMenu = document.querySelector('.context-menu');
                if (existingMenu) {
                    existingMenu.remove();
                }
                
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.left = `${e.clientX}px`;
                menu.style.top = `${e.clientY}px`;
                
                const centerItem = document.createElement('div');
                centerItem.className = 'context-menu-item';
                centerItem.textContent = 'å›åˆ°ä¸­å¿ƒ';
                centerItem.addEventListener('click', () => {
                    resetCanvas();
                    menu.remove();
                });
                
                menu.appendChild(centerItem);
                document.body.appendChild(menu);
                
                const closeMenu = () => {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                };
                
                setTimeout(() => {
                    document.addEventListener('click', closeMenu);
                }, 0);
            });
            
            if (resetCanvasBtn) {
                resetCanvasBtn.addEventListener('click', resetCanvas);
            }
            
            initMinimap();
            console.log('Canvas initialized successfully');
        }

        // ç”Ÿæˆè°ƒè¯•ç½‘æ ¼
        function generateDebugGrid() {
            const svg = document.getElementById('debugGridSvg');
            if (!svg) return;
            
            let svgContent = '';
            
            // ç”Ÿæˆç½‘æ ¼çº¿
            for (let i = 0; i <= 100; i++) {
                const pos = i * 100;
                // å‚ç›´çº¿
                svgContent += `<line x1="${pos}" y1="0" x2="${pos}" y2="10000" stroke="#00ff00" stroke-width="1" stroke-opacity="0.2"/>`;
                // æ°´å¹³çº¿
                svgContent += `<line x1="0" y1="${pos}" x2="10000" y2="${pos}" stroke="#00ff00" stroke-width="1" stroke-opacity="0.2"/>`;
            }
            
            // ç”Ÿæˆç½‘æ ¼æ–‡å­—ï¼ˆæ¯ä¸ªæ ¼å­ä¸­å¿ƒï¼‰
            for (let row = 1; row <= 100; row++) {
                for (let col = 1; col <= 100; col++) {
                    const x = (col - 1) * 100 + 50;
                    const y = (row - 1) * 100 + 50;
                    svgContent += `<text x="${x}" y="${y}" font-size="12" text-anchor="middle" dominant-baseline="middle" fill="#00ff00" fill-opacity="0.5">${row}.${col}</text>`;
                }
            }
            
            svg.innerHTML = svgContent;
        }

        function resetCanvas() {
            if (panzoom) {
                panzoom.reset();
                refreshUI();
            }
        }

        // ç®€å•çš„UIåˆ·æ–°å‡½æ•°
        function refreshUI() {
            updateCenterMarkerCoordinates();
            updateMinimapViewport();
        }

        // æ›´æ–°ä¸­å¿ƒæ ‡è®°çš„åæ ‡æ˜¾ç¤º
        function updateCenterMarkerCoordinates() {
            const centerMarker = document.getElementById('canvasCenterMarker');
            if (!centerMarker) return;
            
            // è®¡ç®—è§†å£ä¸­å¿ƒåæ ‡ï¼Œè€ƒè™‘å³ä¾§é¢æ¿è¡¥å¿
            const uiPanel = document.getElementById('uiPanel');
            const uiPanelWidth = uiPanel ? uiPanel.offsetWidth : 400;
            const viewportCenterX = (window.innerWidth - uiPanelWidth) / 2;
            const viewportCenterY = window.innerHeight / 2;
            
            // ä¿®æ­£åçš„å…¬å¼ï¼š(è§†å£ä¸­å¿ƒç›¸å¯¹äºç”»å¸ƒå·¦ä¸Šè§’çš„ç»å¯¹ä½ç½®)
            const scale = panzoom.getScale();
            const displayX = Math.round((viewportCenterX - AppState.panX) / scale);
            const displayY = Math.round((viewportCenterY - AppState.panY) / scale);
            
            // æ›´æ–°åæ ‡æ˜¾ç¤º
            const coordText = centerMarker.querySelector('div:nth-child(2)');
            if (coordText) {
                coordText.textContent = `ä¸­å¿ƒåæ ‡: (${displayX}, ${displayY})`;
            }
        }
        
        function updateImageCenterCoordinates(node) {
            if (!node) return;
            
            // è·å–å›¾ç‰‡ä½ç½®å’Œå°ºå¯¸
            const left = parseInt(node.style.left) || 0;
            const top = parseInt(node.style.top) || 0;
            const width = parseInt(node.dataset.width) || 500;
            const height = parseInt(node.dataset.height) || 500;
            
            // è®¡ç®—ä¸­å¿ƒåæ ‡
            const centerX = Math.round(left + width / 2);
            const centerY = Math.round(top + height / 2);
            
            // æ›´æ–°åæ ‡æ˜¾ç¤º
            const coordsElement = node.querySelector('.node-center-coords');
            if (coordsElement) {
                coordsElement.textContent = `(${centerX}, ${centerY})`;
            }
        }

        function updateMinimapViewport() {
            const ratio = 200 / 10000;
            const viewportBox = document.getElementById('minimapViewport');
            const uiPanel = document.getElementById('uiPanel');
            const uiPanelWidth = uiPanel ? uiPanel.offsetWidth : 400;

            if (!viewportBox || typeof AppState.panX === 'undefined') return;

            // 1. ç‰©ç†è§†å£å®½é«˜
            const vW_phys = window.innerWidth - uiPanelWidth;
            const vH_phys = window.innerHeight;

            // 2. è“æ¡†å¤§å° (æ­£æ¯”äºç‰©ç†è§†å£ï¼Œåæ¯”äºç¼©æ”¾å€æ•°)
            const vW_minimap = (vW_phys / AppState.scale) * ratio;
            const vH_minimap = (vH_phys / AppState.scale) * ratio;

            // 3. ã€æ ¸å¿ƒä¿®å¤ã€‘è®¡ç®—å½“å‰å±å¹•æ­£ä¸­å¿ƒï¼Œåœ¨ 10000x10000 é€»è¾‘ç”»å¸ƒä¸Šçš„ç»å¯¹åæ ‡
            // å…¬å¼ï¼šä¸­å¿ƒåŸºå‡† 5000 + (ç‰©ç†ä¸­å¿ƒç‚¹ - ä¸­å¿ƒåŸå‡†ç‚¹ 5000 - ç‰©ç†åç§») / ç¼©æ”¾å€æ•°
            const logicCenterX = 5000 + (vW_phys / 2 - 5000 - AppState.panX) / AppState.scale;
            const logicCenterY = 5000 + (vH_phys / 2 - 5000 - AppState.panY) / AppState.scale;

            // 4. å°†é€»è¾‘ä¸­å¿ƒæ˜ å°„åˆ°ç¼©ç•¥å›¾ï¼Œå¹¶å‡å»è“æ¡†è‡ªèº«çš„ä¸€åŠï¼Œå®ç°å®Œç¾å±…ä¸­
            const minimapCenterX = logicCenterX * ratio;
            const minimapCenterY = logicCenterY * ratio;

            viewportBox.style.width = `${vW_minimap}px`;
            viewportBox.style.height = `${vH_minimap}px`;
            viewportBox.style.left = `${minimapCenterX - vW_minimap / 2}px`;
            viewportBox.style.top = `${minimapCenterY - vH_minimap / 2}px`;
        }

        function updateMinimapWithImage(node) {
            const minimapScale = 200 / 10000;
            const img = node.querySelector('img');
            
            if (!img) {
                return;
            }
            
            if (!img.complete) {
                img.onload = () => updateMinimapWithImage(node);
                return;
            }
            
            const nodeLeft = parseInt(node.style.left) || 0;
            const nodeTop = parseInt(node.style.top) || 0;
            const nodeWidth = img.offsetWidth || parseInt(img.style.width) || 200;
            const nodeHeight = img.offsetHeight || parseInt(img.style.height) || 200;
            
            // ç”»å¸ƒçš„(5000, 5000)å¯¹åº”ç¼©ç•¥å›¾çš„(100, 100)
            const minimapLeft = 100 + (nodeLeft - 5000) * minimapScale;
            const minimapTop = 100 + (nodeTop - 5000) * minimapScale;
            const minimapWidth = nodeWidth * minimapScale;
            const minimapHeight = nodeHeight * minimapScale;
            
            let minimapImage = minimapCanvas.querySelector(`[data-node-id="${node.dataset.index}"]`);
            
            if (!minimapImage) {
                minimapImage = document.createElement('div');
                minimapImage.className = 'minimap-image';
                minimapImage.dataset.nodeId = node.dataset.index;
                minimapImage.style.zIndex = '1';
                minimapCanvas.appendChild(minimapImage);
            }
            
            minimapImage.style.left = `${minimapLeft}px`;
            minimapImage.style.top = `${minimapTop}px`;
            minimapImage.style.width = `${minimapWidth}px`;
            minimapImage.style.height = `${minimapHeight}px`;
        }

        function updateAllMinimapImages() {
            const nodes = imageResponseContainer.querySelectorAll('.canvas-node');
            nodes.forEach(node => {
                updateMinimapWithImage(node);
            });
        }

        function initMinimap() {
            updateMinimapViewport();
            updateAllMinimapImages();
            
            // ä¿®å¤ 1ï¼šç‚¹å‡»ç¼©ç•¥å›¾è·³è½¬é€»è¾‘
            minimapCanvas.addEventListener('click', (e) => {
                if (e.target === minimapViewport) return;
                
                const rect = minimapCanvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                const minimapScale = 200 / 10000;
                const scale = panzoom.getScale();
                
                const targetLogicX = clickX / minimapScale;
                const targetLogicY = clickY / minimapScale;
                
                const uiPanel = document.getElementById('uiPanel');
                const uiPanelWidth = uiPanel ? uiPanel.offsetWidth : 400;
                const vW_phys = window.innerWidth - uiPanelWidth;
                const vH_phys = window.innerHeight;

                // ã€åå‘æ¨å¯¼å…¬å¼ã€‘ç®—å‡ºè¦è®©è¯¥ç‚¹å±…ä¸­ï¼Œéœ€è¦å¤šå°‘ç‰©ç†åç§»
                const newPanX = vW_phys / 2 - 5000 - (targetLogicX - 5000) * scale;
                const newPanY = vH_phys / 2 - 5000 - (targetLogicY - 5000) * scale;
                
                // äº¤ç»™ panzoom å¤„ç†ï¼Œå®ƒä¼šè‡ªåŠ¨æ›´æ–°æ ·å¼å¹¶è§¦å‘ panzoompan äº‹ä»¶
                panzoom.pan(newPanX, newPanY);
            });
            
            minimapViewport.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDraggingMinimapViewport = true;
                minimapDragStartX = e.clientX;
                minimapDragStartY = e.clientY;
                minimapPanStartX = AppState.panX;
                minimapPanStartY = AppState.panY;
            });
            
            // ä¿®å¤ 2ï¼šæ‹–æ‹½è“æ¡†é€»è¾‘ï¼ˆä¿®æ­£æ­£è´Ÿå·å’Œä¹˜é™¤æ³•ï¼‰
            document.addEventListener('mousemove', (e) => {
                if (isDraggingMinimapViewport) {
                    const deltaX = e.clientX - minimapDragStartX;
                    const deltaY = e.clientY - minimapDragStartY;
                    
                    const minimapScale = 200 / 10000;
                    const scale = panzoom.getScale();
                    
                    // ã€æ ¸å¿ƒä¿®æ­£ã€‘è“æ¡†å¾€å³èµ°(æ­£)ï¼Œä»£è¡¨è§†å£å¾€å³ï¼Œæ„å‘³ç€ç”»å¸ƒå¿…é¡»å¾€å·¦é€€(è´Ÿ)ï¼å¹¶ä¸”å¿…é¡»ä¹˜ä¸Š scaleã€‚
                    const newPanX = minimapPanStartX - (deltaX / minimapScale) * scale;
                    const newPanY = minimapPanStartY - (deltaY / minimapScale) * scale;
                    
                    panzoom.pan(newPanX, newPanY);
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDraggingMinimapViewport) {
                    isDraggingMinimapViewport = false;
                }
            });
        }

        uploadImageBtn.addEventListener('click', () => {
            imageUploadInput.click();
        });

        imageUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const imageUrl = event.target.result;
                    const node = createImageNode(imageUrl, file.name, nodeCounter++, file.name, '');
                    imageResponseContainer.appendChild(node);
                    debugLog(`[å›¾ç‰‡ä¸Šä¼ ] æ–‡ä»¶å: ${file.name}`, 'info');
                };
                reader.readAsDataURL(file);
            }
            imageUploadInput.value = '';
        });

        // ç¼©æ”¾æ§åˆ¶äº‹ä»¶
        zoomSlider.addEventListener('input', (e) => {
            const newScale = parseInt(e.target.value) / 100;
            updateCanvasScale(newScale);
        });

        zoomOutBtn.addEventListener('click', () => {
            const currentScale = panzoom.getScale();
            const newScale = Math.max(0.5, currentScale - 0.25);
            updateCanvasScale(newScale);
        });

        zoomInBtn.addEventListener('click', () => {
            const currentScale = panzoom.getScale();
            const newScale = Math.min(2.5, currentScale + 0.25);
            updateCanvasScale(newScale);
        });

        zoomResetBtn.addEventListener('click', () => {
            updateCanvasScale(1);
        });

        zoomValue.addEventListener('click', () => {
            updateCanvasScale(1);
        });

        function updateCanvasScale(newScale) {
            const uiPanel = document.getElementById('uiPanel');
            const uiPanelWidth = uiPanel ? uiPanel.offsetWidth : 400;
            
            const focalX = (window.innerWidth - uiPanelWidth) / 2;
            const focalY = window.innerHeight / 2;
            
            const focalPoint = { x: focalX, y: focalY };
            
            panzoom.zoom(newScale, { focalPoint, animate: true });
            zoomSlider.value = Math.round(newScale * 100);
            zoomValue.textContent = `${Math.round(newScale * 100)}%`;
            debugLog(`[ç¼©æ”¾] æ–°ç¼©æ”¾: ${Math.round(newScale * 100)}%`, 'info');
        }

        document.addEventListener('mousemove', (e) => {
            if (AppState.isDraggingNode && AppState.dragNode) {
                const scale = panzoom.getScale();
                const deltaX = (e.clientX - AppState.dragStartX) / scale;
                const deltaY = (e.clientY - AppState.dragStartY) / scale;
                
                const newLeft = AppState.dragNodeStartLeft + deltaX;
                const newTop = AppState.dragNodeStartTop + deltaY;
                
                AppState.dragNode.style.left = `${newLeft}px`;
                AppState.dragNode.style.top = `${newTop}px`;
                
                // æ›´æ–°å›¾ç‰‡ä¸­å¿ƒåæ ‡
                updateImageCenterCoordinates(AppState.dragNode);
                
                updateMinimapWithImage(AppState.dragNode);
                
                if (showMouseLogs) {
                    debugLog(`æ‹–åŠ¨å›¾ç‰‡: delta=(${deltaX},${deltaY}), newPos=(${newLeft},${newTop}), scale=${scale}`, 'event');
                }
            }
            
            if (AppState.isMiddleMouseDown && !AppState.isDraggingNode) {
                const deltaX = e.clientX - AppState.lastMouseX;
                const deltaY = e.clientY - AppState.lastMouseY;
                
                const newPanX = AppState.panX + deltaX;
                const newPanY = AppState.panY + deltaY;
                
                // è®¾ç½®åˆç†çš„è¾¹ç•Œé™åˆ¶ï¼Œé˜²æ­¢ç”¨æˆ·å¤±æ‰‹ç”©é£ç”»å¸ƒ
                // ç”»å¸ƒå°ºå¯¸æ˜¯10000Ã—10000ï¼Œä¸­å¿ƒåœ¨(0,0)ï¼Œæ‰€ä»¥è¾¹ç•Œæ˜¯Â±5000
                // è®¾ç½®ä¸€ä¸ªå¼¹æ€§è¾¹ç•ŒÂ±8000ï¼Œå…è®¸ä¸€å®šçš„æ‹–å‡ºèŒƒå›´
                const minPanX = -8000;
                const maxPanX = 8000;
                const minPanY = -8000;
                const maxPanY = 8000;
                
                AppState.panX = Math.max(minPanX, Math.min(newPanX, maxPanX));
                AppState.panY = Math.max(minPanY, Math.min(newPanY, maxPanY));
                
                // ä½¿ç”¨requestAnimationFrameç¡®ä¿åæ ‡æ›´æ–°ä¸æµè§ˆå™¨æ¸²æŸ“åŒæ­¥
                requestAnimationFrame(() => {
                    const scale = panzoom.getScale();
                    canvas.style.transform = `translate(${AppState.panX}px, ${AppState.panY}px) scale(${scale})`;
                    updateMinimapViewport();
                    updateCenterMarkerCoordinates();
                });
                
                // å…ˆè®¡ç®—deltaXå’ŒdeltaYï¼Œå†æ›´æ–°lastMouseXå’ŒlastMouseY
                AppState.lastMouseX = e.clientX;
                AppState.lastMouseY = e.clientY;
                
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    if (!debugConsole.contains(e.target) && showMouseLogs) {
                        debugLog(`ç”»å¸ƒæ‹–åŠ¨: deltaX=${deltaX}, deltaY=${deltaY}, panX=${AppState.panX}, panY=${AppState.panY}`, 'event');
                    }
                }
            }
            
            if (AppState.isResizingNode && AppState.resizeNode) {
                const deltaX = e.clientX - AppState.resizeStart.x;
                const deltaY = e.clientY - AppState.resizeStart.y;
                const delta = (deltaX >= 0 || deltaY >= 0) ? Math.max(deltaX, deltaY) : Math.min(deltaX, deltaY);
                
                const aspectRatio = AppState.resizeStart.width / AppState.resizeStart.height;
                let newWidth = AppState.resizeStart.width + delta;
                let newHeight = newWidth / aspectRatio;
                
                if (newWidth > 50 && newHeight > 50) {
                    const img = AppState.resizeNode.querySelector('img');
                    img.style.width = `${newWidth}px`;
                    img.style.height = `${newHeight}px`;
                    updateMinimapWithImage(AppState.resizeNode);
                    refreshPinsOnNode(AppState.resizeNode);
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (debugConsole.contains(e.target)) return;
            if (showMouseLogs) {
                debugLog(`[é¼ æ ‡æŠ¬èµ·] å…¨å±€: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}`, 'event');
            }
            
            if (AppState.isDraggingNode && AppState.dragNode) {
                if (showMouseLogs) {
                    debugLog(`[ç»“æŸæ‹–åŠ¨] å›¾ç‰‡: node=${AppState.dragNode.dataset.filename}`, 'info');
                }
                AppState.dragNode.style.cursor = 'grab';
                AppState.isDraggingNode = false;
                AppState.dragNode = null;
            }
            
            if (AppState.isResizingNode && AppState.resizeNode) {
                if (showMouseLogs) {
                    debugLog(`[ç»“æŸè°ƒæ•´å¤§å°] èŠ‚ç‚¹: node=${AppState.resizeNode.dataset.filename}`, 'info');
                }
                AppState.isResizingNode = false;
                AppState.resizeNode = null;
                document.body.style.cursor = '';
            }
            
            if (AppState.isMiddleMouseDown) {
                if (showMouseLogs) {
                    debugLog(`[é¼ æ ‡ä¸­é”®é‡Šæ”¾] å…¨å±€: isMiddleMouseDown=${AppState.isMiddleMouseDown}`, 'info');
                }
                AppState.isMiddleMouseDown = false;
                canvasViewport.style.cursor = 'default';
            }
        });

        function createImageNode(imageUrl, prompt = '', index = 0, filename = '', resolution = '') {
            console.log('Creating image node...');
            console.log('Image URL:', imageUrl);
            console.log('Prompt:', prompt);
            console.log('Index:', index);
            console.log('Filename:', filename);
            console.log('Resolution:', resolution);
            
            const node = document.createElement('div');
            node.className = 'canvas-node';
            node.dataset.index = index;
            node.dataset.imageUrl = imageUrl;
            node.dataset.filename = filename || `Image ${index + 1}`;
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = `Generated image ${index + 1}`;
            img.draggable = false;
            
            img.onload = function() {
                const width = this.naturalWidth;
                const height = this.naturalHeight;
                const resolutionText = `${width}x${height}`;
                const resolutionElement = node.querySelector('.node-resolution');
                if (resolutionElement) {
                    resolutionElement.textContent = resolutionText;
                }
                node.dataset.width = width;
                node.dataset.height = height;
                
                // æ›´æ–°å›¾ç‰‡ä¸­å¿ƒåæ ‡
                updateImageCenterCoordinates(node);
            };
            
            const header = document.createElement('div');
            header.className = 'node-header';
            
            const filenameElement = document.createElement('div');
            filenameElement.className = 'node-filename';
            filenameElement.textContent = filename || `Image ${index + 1}`;
            
            const resolutionElement = document.createElement('div');
            resolutionElement.className = 'node-resolution';
            resolutionElement.textContent = resolution || 'Loading...';
            
            header.appendChild(filenameElement);
            header.appendChild(resolutionElement);
            
            // åˆ›å»ºæ‚¬æµ®å·¥å…·æ 
            const toolbar = document.createElement('div');
            toolbar.className = 'node-toolbar';
            
            // æ·»åŠ å¤åˆ¶æç¤ºè¯æŒ‰é’®
            const copyPromptBtn = document.createElement('button');
            copyPromptBtn.className = 'toolbar-btn';
            copyPromptBtn.innerHTML = 'ğŸ“';
            copyPromptBtn.title = 'å¤åˆ¶æç¤ºè¯';
            copyPromptBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(prompt || '').then(() => {
                    if (showMouseLogs) {
                        debugLog(`[å¤åˆ¶] æç¤ºè¯: ${node.dataset.filename}`, 'info');
                    }
                });
            });
            
            // æ·»åŠ æ’å…¥åˆ°è¾“å…¥æ¡†æŒ‰é’®
            const insertBtn = document.createElement('button');
            insertBtn.className = 'toolbar-btn';
            insertBtn.innerHTML = 'âœï¸';
            insertBtn.title = 'æ’å…¥åˆ°è¾“å…¥æ¡†';
            insertBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const img = node.querySelector('img');
                if (img) {
                    const imageUrl = img.src;
                    const filename = node.dataset.filename || 'Image';
                    insertImageToPrompt(imageUrl, filename);
                    debugLog(`[å·¥å…·æ ] æ’å…¥å›¾ç‰‡åˆ°è¾“å…¥æ¡†: node=${node.dataset.filename}`, 'info');
                }
            });
            
            // æ·»åŠ å¤åˆ¶æŒ‰é’®
            const copyBtn = document.createElement('button');
            copyBtn.className = 'toolbar-btn';
            copyBtn.innerHTML = 'ğŸ“‹';
            copyBtn.title = 'å¤åˆ¶å›¾ç‰‡';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(node);
                copySelectedNode();
            });
            
            // æ·»åŠ åˆ é™¤æŒ‰é’®
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'toolbar-btn';
            deleteBtn.innerHTML = 'ğŸ—‘ï¸';
            deleteBtn.title = 'åˆ é™¤å›¾ç‰‡';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(node);
                deleteSelectedNode();
            });
            
            toolbar.appendChild(copyPromptBtn);
            toolbar.appendChild(insertBtn);
            toolbar.appendChild(copyBtn);
            toolbar.appendChild(deleteBtn);
            
            // åˆ›å»ºä¸­å¿ƒåæ ‡æ˜¾ç¤º
            const centerCoords = document.createElement('div');
            centerCoords.className = 'node-center-coords';
            centerCoords.textContent = '(0, 0)';
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            
            const info = document.createElement('div');
            info.className = 'node-info';
            info.textContent = prompt || `Image ${index + 1}`;
            
            node.appendChild(header);
            node.appendChild(toolbar);
            node.appendChild(img);
            node.appendChild(resizeHandle);
            node.appendChild(info);
            node.appendChild(centerCoords);
            
            node.dataset.pins = JSON.stringify([]);
            
            // ç›´æ¥è®¾ç½®ä¸­å¿ƒä½ç½®ï¼Œä¸éœ€è¦ç­‰å¾…onloadäº‹ä»¶
            const width = parseInt(img.style.width) || 500;
            const height = parseInt(img.style.height) || 500;
            // è®¾ç½®ä¸ºç”»å¸ƒä¸­å¿ƒ (0, 0)ï¼Œè¿™æ ·ä¼šæ˜¾ç¤ºåœ¨è§†å£ä¸­å¿ƒ
            node.style.left = `${5000 - width / 2}px`;
            node.style.top = `${5000 - height / 2}px`;
            
            // å¯¹äºå¯èƒ½éœ€è¦è®¡ç®—å®é™…å°ºå¯¸çš„å›¾ç‰‡ï¼Œä»ç„¶æ·»åŠ onloadäº‹ä»¶
            img.onload = function() {
                const actualWidth = this.naturalWidth || parseInt(this.style.width) || 500;
                const actualHeight = this.naturalHeight || parseInt(this.style.height) || 500;
                // ä¿æŒåœ¨ç”»å¸ƒä¸­å¿ƒ
                node.style.left = `${5000 - actualWidth / 2}px`;
                node.style.top = `${5000 - actualHeight / 2}px`;
                
                // æ›´æ–°åˆ†è¾¨ç‡æ˜¾ç¤º
                const resolutionText = `${actualWidth}x${actualHeight}`;
                const resolutionElement = node.querySelector('.node-resolution');
                if (resolutionElement) {
                    resolutionElement.textContent = resolutionText;
                }
                
                // æ›´æ–°èŠ‚ç‚¹æ•°æ®
                node.dataset.width = actualWidth;
                node.dataset.height = actualHeight;
                
                // æ›´æ–°å›¾ç‰‡ä¸­å¿ƒåæ ‡
                updateImageCenterCoordinates(node);
                
                // æ›´æ–°ç¼©ç•¥å›¾
                updateMinimapWithImage(node);
            };
            
            // ç«‹å³æ›´æ–°ç¼©ç•¥å›¾
            updateMinimapWithImage(node);
            
            img.addEventListener('click', (e) => {
                e.stopPropagation();
                if (showMouseLogs) {
                    debugLog(`å›¾ç‰‡ç‚¹å‡»: button=${e.button}, ctrlKey=${e.ctrlKey}, metaKey=${e.metaKey}, selected=${node.classList.contains('selected')}`, 'event');
                }
                if (e.ctrlKey || e.metaKey) {
                    if (node.classList.contains('selected')) {
                        if (showMouseLogs) {
                            debugLog(`æ·»åŠ  PIN: å›¾ç‰‡å·²é€‰ä¸­`, 'info');
                        }
                        addPinToImage(node, e);
                    } else {
                        if (showMouseLogs) {
                            debugLog(`é€‰ä¸­å›¾ç‰‡: æœªé€‰ä¸­ï¼ŒæŒ‰ä½ Ctrl/Meta`, 'info');
                        }
                        selectNode(node);
                    }
                } else {
                    if (showMouseLogs) {
                        debugLog(`é€‰ä¸­å›¾ç‰‡: å·¦é”®ç‚¹å‡»`, 'info');
                    }
                    selectNode(node);
                }
            });
            
            node.addEventListener('mousedown', (e) => {
                if (showMouseLogs) {
                    debugLog(`[é¼ æ ‡æŒ‰ä¸‹] èŠ‚ç‚¹: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}, selected=${node.classList.contains('selected')}, ctrlKey=${e.ctrlKey}, metaKey=${e.metaKey}`, 'event');
                }
                if (e.button === 0 && !e.ctrlKey && !e.metaKey) {
                    e.stopPropagation();
                    selectNode(node);
                    
                    // è®¾ç½®å…¨å±€æ‹–åŠ¨çŠ¶æ€
                    AppState.isDraggingNode = true;
                    AppState.dragNode = node;
                    AppState.activeNode = node;
                    
                    // è®°å½•åˆå§‹ä½ç½®
                    AppState.dragStartX = e.clientX;
                    AppState.dragStartY = e.clientY;
                    AppState.dragNodeStartLeft = parseInt(node.style.left || '0');
                    AppState.dragNodeStartTop = parseInt(node.style.top || '0');
                    
                    if (showMouseLogs) {
                        debugLog(`[å¼€å§‹æ‹–åŠ¨] å›¾ç‰‡: node=${node.dataset.filename}`, 'info');
                    }
                }
            });
            
            node.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showImageContextMenu(e, node, img);
            });
            
            img.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showImageContextMenu(e, node, img);
            });
            
            resizeHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                startResizeNode(e, node);
            });
            
            console.log('Node created:', node);
            return node;
        }

        function selectNode(node) {
            if (selectedNode) {
                selectedNode.classList.remove('selected');
            }
            selectedNode = node;
            node.classList.add('selected');
        }



        function startResizeNode(e, node) {
            AppState.isResizingNode = true;
            AppState.resizeNode = node;
            const img = node.querySelector('img');
            AppState.resizeStart = {
                x: e.clientX,
                y: e.clientY,
                width: img.width,
                height: img.height
            };
            document.body.style.cursor = 'nwse-resize';
        }

        canvas.addEventListener('click', (e) => {
            if (debugConsole.contains(e.target)) return;
            
            // è®©è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹
            if (document.activeElement === promptInput) {
                promptInput.blur();
            }
            
            if (showMouseLogs) {
                debugLog(`ç”»å¸ƒç‚¹å‡»: button=${e.button}, target=${e.target.id || e.target.className}`, 'event');
            }
            if (e.target === canvas || e.target === imageResponseContainer) {
                if (showMouseLogs) {
                    debugLog(`å–æ¶ˆé€‰ä¸­æ‰€æœ‰èŠ‚ç‚¹`, 'info');
                }
                deselectAllNodes();
            }
        });

        function deselectAllNodes() {
            if (selectedNode) {
                selectedNode.classList.remove('selected');
                selectedNode = null;
            }
        }

        let clipboardNode = null;

        function copySelectedNode() {
            if (!selectedNode) return;
            
            const img = selectedNode.querySelector('img');
            if (!img) return;
            
            if (img.src.startsWith('data:')) {
                navigator.clipboard.writeText(img.src).then(() => {
                    console.log('å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    if (showMouseLogs) {
                        debugLog(`[å¤åˆ¶] å›¾ç‰‡: ${selectedNode.dataset.filename}`, 'info');
                    }
                    clipboardNode = selectedNode;
                }).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    debugLog(`[å¤åˆ¶å¤±è´¥] ${err}`, 'error');
                });
            } else {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.naturalWidth || img.width;
                canvas.height = img.naturalHeight || img.height;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                canvas.toBlob((blob) => {
                    navigator.clipboard.write([
                        new ClipboardItem({
                            'image/png': blob
                        })
                    ]).then(() => {
                        console.log('å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        if (showMouseLogs) {
                            debugLog(`[å¤åˆ¶] å›¾ç‰‡: ${selectedNode.dataset.filename}`, 'info');
                        }
                        clipboardNode = selectedNode;
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                        debugLog(`[å¤åˆ¶å¤±è´¥] ${err}`, 'error');
                    });
                });
            }
        }

        function cutSelectedNode() {
            if (!selectedNode) return;
            
            clipboardNode = selectedNode.cloneNode(true);
            deleteSelectedNode(true);
            debugLog(`[å‰ªåˆ‡] å›¾ç‰‡: ${selectedNode.dataset.filename}`, 'info');
        }

        function deleteSelectedNode(skipConfirm = false) {
            if (!selectedNode) return;
            
            const showDeleteConfirm = () => {
                const confirmModal = document.getElementById('confirmModal');
                const confirmModalMessage = document.getElementById('confirmModalMessage');
                const confirmModalCheckbox = document.getElementById('confirmModalCheckbox');
                const confirmModalCancel = document.getElementById('confirmModalCancel');
                const confirmModalOk = document.getElementById('confirmModalOk');
                
                confirmModalMessage.textContent = `ç¡®å®šè¦åˆ é™¤å›¾ç‰‡"${selectedNode.dataset.filename}"å—ï¼Ÿ`;
                confirmModal.classList.remove('hidden');
                confirmModal.classList.add('flex');
                
                const handleConfirm = () => {
                    const dontShowAgain = confirmModalCheckbox.checked;
                    
                    if (dontShowAgain) {
                        localStorage.setItem('dontShowDeleteConfirm', 'true');
                    }
                    
                    performDelete();
                    closeConfirmModal();
                };
                
                const handleCancel = () => {
                    closeConfirmModal();
                };
                
                const closeConfirmModal = () => {
                    confirmModal.classList.add('hidden');
                    confirmModal.classList.remove('flex');
                    confirmModalOk.removeEventListener('click', handleConfirm);
                    confirmModalCancel.removeEventListener('click', handleCancel);
                };
                
                confirmModalOk.addEventListener('click', handleConfirm);
                confirmModalCancel.addEventListener('click', handleCancel);
            };
            
            const performDelete = () => {
                const minimapImage = minimapCanvas.querySelector(`[data-node-id="${selectedNode.dataset.index}"]`);
                if (minimapImage) {
                    minimapImage.remove();
                }
                selectedNode.remove();
                selectedNode = null;
                debugLog(`[åˆ é™¤] å›¾ç‰‡: ${selectedNode?.dataset.filename}`, 'info');
            };
            
            const dontShowConfirm = localStorage.getItem('dontShowDeleteConfirm') === 'true';
            
            if (skipConfirm || dontShowConfirm) {
                performDelete();
            } else {
                showDeleteConfirm();
            }
        }

        function pasteNode() {
            if (!clipboardNode) return;
            
            const imageUrl = clipboardNode.dataset.imageUrl;
            const prompt = clipboardNode.querySelector('.node-info')?.textContent || '';
            const filename = clipboardNode.dataset.filename;
            const resolution = `${clipboardNode.dataset.width || 500}x${clipboardNode.dataset.height || 500}`;
            
            const newNode = createImageNode(imageUrl, prompt, nodeCounter++, filename, resolution);
            
            // åç§»ä¸€ç‚¹ä½ç½®ï¼Œé¿å…å®Œå…¨é‡å 
            const offsetX = 20;
            const offsetY = 20;
            const currentLeft = parseInt(clipboardNode.style.left) || 5000;
            const currentTop = parseInt(clipboardNode.style.top) || 5000;
            newNode.style.left = `${currentLeft + offsetX}px`;
            newNode.style.top = `${currentTop + offsetY}px`;
            
            // æ·»åŠ åˆ°ç”»å¸ƒ
            imageResponseContainer.appendChild(newNode);
            
            // é€‰ä¸­èŠ‚ç‚¹
            selectNode(newNode);
            
            // æ›´æ–°ç¼©ç•¥å›¾
            updateMinimapWithImage(newNode);
            
            debugLog(`[ç²˜è´´] å›¾ç‰‡: ${newNode.dataset.filename}`, 'info');
        }

        function createTextNode(text, prompt = '', index = 0) {
            const node = document.createElement('div');
            node.className = 'canvas-node text-node';
            node.dataset.index = index;
            node.dataset.filename = `Text ${index + 1}`;
            node.dataset.nodeType = 'text';
            
            const promptElement = document.createElement('div');
            promptElement.className = 'text-prompt';
            promptElement.textContent = prompt || 'æ–‡æœ¬å›å¤';
            
            const textContent = document.createElement('div');
            textContent.className = 'text-content';
            textContent.textContent = text;
            
            const toolbar = document.createElement('div');
            toolbar.className = 'node-toolbar';
            
            const copyPromptBtn = document.createElement('button');
            copyPromptBtn.className = 'toolbar-btn';
            copyPromptBtn.innerHTML = 'ğŸ“';
            copyPromptBtn.title = 'å¤åˆ¶æç¤ºè¯';
            copyPromptBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(prompt || '').then(() => {
                    if (showMouseLogs) {
                        debugLog(`[å¤åˆ¶] æç¤ºè¯: ${node.dataset.filename}`, 'info');
                    }
                });
            });
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'toolbar-btn';
            copyBtn.innerHTML = 'ğŸ“‹';
            copyBtn.title = 'å¤åˆ¶æ–‡æœ¬';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(text).then(() => {
                    if (showMouseLogs) {
                        debugLog(`[å¤åˆ¶] æ–‡æœ¬èŠ‚ç‚¹: ${node.dataset.filename}`, 'info');
                    }
                });
            });
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'toolbar-btn';
            deleteBtn.innerHTML = 'ğŸ—‘ï¸';
            deleteBtn.title = 'åˆ é™¤èŠ‚ç‚¹';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(node);
                deleteSelectedNode();
            });
            
            toolbar.appendChild(copyPromptBtn);
            toolbar.appendChild(copyBtn);
            toolbar.appendChild(deleteBtn);
            
            node.appendChild(promptElement);
            node.appendChild(textContent);
            node.appendChild(toolbar);
            
            node.style.left = '5000px';
            node.style.top = '5000px';
            
            node.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !e.target.closest('.toolbar-btn')) {
                    if (showMouseLogs) {
                        debugLog(`[å¼€å§‹æ‹–åŠ¨] æ–‡æœ¬èŠ‚ç‚¹: ${node.dataset.filename}`, 'info');
                    }
                    selectNode(node);
                    AppState.isDraggingNode = true;
                    AppState.dragNode = node;
                    AppState.dragStartX = e.clientX;
                    AppState.dragStartY = e.clientY;
                    AppState.dragNodeStartLeft = parseInt(node.style.left) || 5000;
                    AppState.dragNodeStartTop = parseInt(node.style.top) || 5000;
                    node.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });
            
            return node;
        }

        function addSampleImage() {
            let svgContent = '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" viewBox="0 0 500 500">';
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9', '#F8B500', '#00CED1', '#FF69B4', '#32CD32', '#FFD700', '#FF6347', '#7B68EE', '#20B2AA', '#FFA500', '#9370DB', '#DC143C', '#00FA9A', '#FF1493', '#00BFFF', '#FF4500'];
            
            let colorIndex = 0;
            for (let row = 1; row <= 5; row++) {
                for (let col = 1; col <= 5; col++) {
                    const x = (col - 1) * 100;
                    const y = (row - 1) * 100;
                    const color = colors[colorIndex % colors.length];
                    
                    svgContent += `<rect x="${x}" y="${y}" width="100" height="100" fill="${color}" stroke="#fff" stroke-width="2"/>`;
                    svgContent += `<text x="${x + 50}" y="${y + 50}" dominant-baseline="middle" text-anchor="middle" font-size="20" font-weight="bold" fill="#fff" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${row}.${col}</text>`;
                    
                    colorIndex++;
                }
            }
            
            svgContent += '</svg>';
            const sampleImageUrl = `data:image/svg+xml,${encodeURIComponent(svgContent)}`;
            
            const existingSample = imageResponseContainer.querySelector('[data-filename="sample_image.png"]');
            if (existingSample) {
                console.log('Sample image already exists, skipping...');
                return;
            }
            
            const node = createImageNode(sampleImageUrl, '5x5 ç½‘æ ¼', nodeCounter++, 'sample_image.png', '500x500');
            imageResponseContainer.appendChild(node);
        }

        function createTextLoadingPlaceholder(prompt, x, y) {
            const node = document.createElement('div');
            node.className = 'canvas-node text-loading-placeholder';
            node.dataset.index = nodeCounter++;
            node.dataset.filename = 'Loading...';
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            
            const loadingText = document.createElement('div');
            loadingText.className = 'loading-text';
            loadingText.textContent = 'æ­£åœ¨ç”Ÿæˆå›å¤...';
            
            node.appendChild(loadingText);
            
            // æ·»åŠ é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼Œç¡®ä¿å¯ä»¥æ‹–åŠ¨
            node.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !e.ctrlKey && !e.metaKey) {
                    e.stopPropagation();
                    selectNode(node);
                    
                    // è®¾ç½®å…¨å±€æ‹–åŠ¨çŠ¶æ€
                    AppState.isDraggingNode = true;
                    AppState.dragNode = node;
                    AppState.activeNode = node;
                    
                    // è®°å½•åˆå§‹ä½ç½®
                    AppState.dragStartX = e.clientX;
                    AppState.dragStartY = e.clientY;
                    AppState.dragNodeStartLeft = parseInt(node.style.left || '0');
                    AppState.dragNodeStartTop = parseInt(node.style.top || '0');
                }
            });
            
            return node;
        }
        
        function updateTextLoadingPlaceholder(node, text, prompt) {
            node.classList.remove('text-loading-placeholder');
            node.classList.add('text-node');
            node.dataset.filename = `Text ${node.dataset.index}`;
            node.dataset.nodeType = 'text';
            
            const loadingText = node.querySelector('.loading-text');
            if (loadingText) {
                loadingText.remove();
            }
            
            const promptElement = document.createElement('div');
            promptElement.className = 'text-prompt';
            promptElement.textContent = prompt || 'æ–‡æœ¬å›å¤';
            
            const textContent = document.createElement('div');
            textContent.className = 'text-content';
            textContent.textContent = text;
            
            const toolbar = document.createElement('div');
            toolbar.className = 'node-toolbar';
            
            const copyPromptBtn = document.createElement('button');
            copyPromptBtn.className = 'toolbar-btn';
            copyPromptBtn.innerHTML = 'ğŸ“';
            copyPromptBtn.title = 'å¤åˆ¶æç¤ºè¯';
            copyPromptBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(prompt || '').then(() => {
                    if (showMouseLogs) {
                        debugLog(`[å¤åˆ¶] æç¤ºè¯: ${node.dataset.filename}`, 'info');
                    }
                });
            });
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'toolbar-btn';
            copyBtn.innerHTML = 'ğŸ“‹';
            copyBtn.title = 'å¤åˆ¶æ–‡æœ¬';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(text).then(() => {
                    if (showMouseLogs) {
                        debugLog(`[å¤åˆ¶] æ–‡æœ¬èŠ‚ç‚¹: ${node.dataset.filename}`, 'info');
                    }
                });
            });
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'toolbar-btn';
            deleteBtn.innerHTML = 'ğŸ—‘ï¸';
            deleteBtn.title = 'åˆ é™¤èŠ‚ç‚¹';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(node);
                deleteSelectedNode();
            });
            
            toolbar.appendChild(copyPromptBtn);
            toolbar.appendChild(copyBtn);
            toolbar.appendChild(deleteBtn);
            
            node.appendChild(promptElement);
            node.appendChild(textContent);
            node.appendChild(toolbar);
            
            node.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !e.target.closest('.toolbar-btn')) {
                    if (showMouseLogs) {
                        debugLog(`[å¼€å§‹æ‹–åŠ¨] æ–‡æœ¬èŠ‚ç‚¹: ${node.dataset.filename}`, 'info');
                    }
                    selectNode(node);
                    AppState.isDraggingNode = true;
                    AppState.dragNode = node;
                    AppState.dragStartX = e.clientX;
                    AppState.dragStartY = e.clientY;
                    AppState.dragNodeStartLeft = parseInt(node.style.left) || 5000;
                    AppState.dragNodeStartTop = parseInt(node.style.top) || 5000;
                    node.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });
        }

        function createLoadingPlaceholder(width, height, x, y) {
            const node = document.createElement('div');
            node.className = 'canvas-node loading-placeholder';
            node.dataset.index = nodeCounter++;
            node.dataset.filename = 'Loading...';
            node.style.width = `${width}px`;
            node.style.height = `${height}px`;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            
            // æ·»åŠ åŠ è½½åŠ¨ç”»
            const loadingContainer = document.createElement('div');
            loadingContainer.className = 'loading-container';
            loadingContainer.style.width = '100%';
            loadingContainer.style.height = '100%';
            loadingContainer.style.display = 'flex';
            loadingContainer.style.flexDirection = 'column';
            loadingContainer.style.justifyContent = 'center';
            loadingContainer.style.alignItems = 'center';
            loadingContainer.style.backgroundColor = '#f3f4f6';
            loadingContainer.style.borderRadius = '8px';
            loadingContainer.style.border = '1px solid #e5e7eb';
            
            const loadingBar = document.createElement('div');
            loadingBar.className = 'loading-bar';
            loadingBar.style.width = '60%';
            loadingBar.style.height = '4px';
            loadingBar.style.backgroundColor = '#e5e7eb';
            loadingBar.style.borderRadius = '2px';
            loadingBar.style.overflow = 'hidden';
            
            const loadingProgress = document.createElement('div');
            loadingProgress.className = 'loading-progress';
            loadingProgress.style.width = '100%';
            loadingProgress.style.height = '100%';
            loadingProgress.style.backgroundColor = '#3b82f6';
            loadingProgress.style.borderRadius = '2px';
            loadingProgress.style.animation = 'loading 1.5s ease-in-out infinite';
            
            const loadingText = document.createElement('div');
            loadingText.className = 'loading-text';
            loadingText.textContent = 'æ­£åœ¨ç”Ÿæˆå›¾ç‰‡...';
            loadingText.style.marginTop = '12px';
            loadingText.style.fontSize = '14px';
            loadingText.style.color = '#6b7280';
            
            loadingBar.appendChild(loadingProgress);
            loadingContainer.appendChild(loadingBar);
            loadingContainer.appendChild(loadingText);
            
            // æ·»åŠ å¤´éƒ¨ä¿¡æ¯
            const header = document.createElement('div');
            header.className = 'node-header';
            
            const filenameElement = document.createElement('div');
            filenameElement.className = 'node-filename';
            filenameElement.textContent = 'Loading...';
            
            const resolutionElement = document.createElement('div');
            resolutionElement.className = 'node-resolution';
            resolutionElement.textContent = 'Generating...';
            
            header.appendChild(filenameElement);
            header.appendChild(resolutionElement);
            
            // åˆ›å»ºæ‚¬æµ®å·¥å…·æ 
            const toolbar = document.createElement('div');
            toolbar.className = 'node-toolbar';
            
            // æ·»åŠ å¤åˆ¶æç¤ºè¯æŒ‰é’®
            const copyPromptBtn = document.createElement('button');
            copyPromptBtn.className = 'toolbar-btn';
            copyPromptBtn.innerHTML = 'ğŸ“';
            copyPromptBtn.title = 'å¤åˆ¶æç¤ºè¯';
            copyPromptBtn.disabled = true;
            copyPromptBtn.style.opacity = '0.5';
            
            // æ·»åŠ æ’å…¥åˆ°è¾“å…¥æ¡†æŒ‰é’®
            const insertBtn = document.createElement('button');
            insertBtn.className = 'toolbar-btn';
            insertBtn.innerHTML = 'âœï¸';
            insertBtn.title = 'æ’å…¥åˆ°è¾“å…¥æ¡†';
            insertBtn.disabled = true;
            insertBtn.style.opacity = '0.5';
            
            // æ·»åŠ å¤åˆ¶æŒ‰é’®
            const copyBtn = document.createElement('button');
            copyBtn.className = 'toolbar-btn';
            copyBtn.innerHTML = 'ğŸ“‹';
            copyBtn.title = 'å¤åˆ¶å›¾ç‰‡';
            copyBtn.disabled = true;
            copyBtn.style.opacity = '0.5';
            
            // æ·»åŠ åˆ é™¤æŒ‰é’®
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'toolbar-btn';
            deleteBtn.innerHTML = 'ğŸ—‘ï¸';
            deleteBtn.title = 'åˆ é™¤å›¾ç‰‡';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('ç¡®å®šè¦å–æ¶ˆç”Ÿæˆå—ï¼Ÿ')) {
                    const minimapImage = minimapCanvas.querySelector(`[data-node-id="${node.dataset.index}"]`);
                    if (minimapImage) {
                        minimapImage.remove();
                    }
                    node.remove();
                }
            });
            
            toolbar.appendChild(copyPromptBtn);
            toolbar.appendChild(insertBtn);
            toolbar.appendChild(copyBtn);
            toolbar.appendChild(deleteBtn);
            
            const info = document.createElement('div');
            info.className = 'node-info';
            info.textContent = 'Loading...';
            
            node.appendChild(header);
            node.appendChild(toolbar);
            node.appendChild(loadingContainer);
            node.appendChild(info);
            
            // æ·»åŠ é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼Œç¡®ä¿å¯ä»¥æ‹–åŠ¨
            node.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !e.ctrlKey && !e.metaKey) {
                    e.stopPropagation();
                    selectNode(node);
                    
                    // è®¾ç½®å…¨å±€æ‹–åŠ¨çŠ¶æ€
                    AppState.isDraggingNode = true;
                    AppState.dragNode = node;
                    AppState.activeNode = node;
                    
                    // è®°å½•åˆå§‹ä½ç½®
                    AppState.dragStartX = e.clientX;
                    AppState.dragStartY = e.clientY;
                    AppState.dragNodeStartLeft = parseInt(node.style.left || '0');
                    AppState.dragNodeStartTop = parseInt(node.style.top || '0');
                }
            });
            
            return node;
        }
        
        function updateLoadingPlaceholder(node, imageUrl, prompt, filename, resolution) {
            // æ›´æ–°èŠ‚ç‚¹å±æ€§
            node.classList.remove('loading-placeholder');
            node.dataset.imageUrl = imageUrl;
            node.dataset.filename = filename || `Image ${node.dataset.index}`;
            
            // æ¸…é™¤å›ºå®šçš„å®½é«˜æ ·å¼ï¼Œè®©å›¾ç‰‡æ­£å¸¸æ˜¾ç¤º
            node.style.width = '';
            node.style.height = '';
            
            // ç§»é™¤åŠ è½½åŠ¨ç”»
            const loadingContainer = node.querySelector('.loading-container');
            if (loadingContainer) {
                loadingContainer.remove();
            }
            
            // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = `Generated image ${node.dataset.index}`;
            img.draggable = false;
            
            // æ·»åŠ è°ƒæ•´å¤§å°æ‰‹æŸ„
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            
            // åˆ›å»ºä¸­å¿ƒåæ ‡æ˜¾ç¤º
            const centerCoords = document.createElement('div');
            centerCoords.className = 'node-center-coords';
            centerCoords.textContent = '(0, 0)';
            
            // æ›´æ–°å¤´éƒ¨ä¿¡æ¯
            const filenameElement = node.querySelector('.node-filename');
            if (filenameElement) {
                filenameElement.textContent = filename || `Image ${node.dataset.index}`;
            }
            
            const resolutionElement = node.querySelector('.node-resolution');
            if (resolutionElement) {
                resolutionElement.textContent = resolution || 'Loading...';
            }
            
            // æ›´æ–°ä¿¡æ¯æ–‡æœ¬
            const info = node.querySelector('.node-info');
            if (info) {
                info.textContent = prompt || `Image ${node.dataset.index}`;
            }
            
            // æ›´æ–°å·¥å…·æ æŒ‰é’®çŠ¶æ€
            const toolbarButtons = node.querySelectorAll('.toolbar-btn');
            toolbarButtons.forEach((btn, index) => {
                if (index < 3) { // å‰ä¸‰ä¸ªæŒ‰é’®ï¼ˆå¤åˆ¶æç¤ºè¯ã€æ’å…¥åˆ°è¾“å…¥æ¡†ã€å¤åˆ¶å›¾ç‰‡ï¼‰
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (index === 0) {
                            // å¤åˆ¶æç¤ºè¯æŒ‰é’®
                            navigator.clipboard.writeText(prompt || '').then(() => {
                                if (showMouseLogs) {
                                    debugLog(`[å¤åˆ¶] æç¤ºè¯: ${node.dataset.filename}`, 'info');
                                }
                            });
                        } else if (index === 1) {
                            // æ’å…¥åˆ°è¾“å…¥æ¡†æŒ‰é’®
                            const imgElement = node.querySelector('img');
                            if (imgElement) {
                                insertImageToPrompt(imgElement.src, node.dataset.filename || 'Image');
                                debugLog(`[å·¥å…·æ ] æ’å…¥å›¾ç‰‡åˆ°è¾“å…¥æ¡†: node=${node.dataset.filename}`, 'info');
                            }
                        } else if (index === 2) {
                            // å¤åˆ¶å›¾ç‰‡æŒ‰é’®
                            selectNode(node);
                            copySelectedNode();
                            debugLog(`[å·¥å…·æ ] å¤åˆ¶å›¾ç‰‡: node=${node.dataset.filename}`, 'info');
                        }
                    });
                }
            });
            
            // æ·»åŠ å›¾ç‰‡åŠ è½½å®Œæˆäº‹ä»¶
            img.onload = function() {
                const actualWidth = this.naturalWidth || parseInt(this.style.width) || 500;
                const actualHeight = this.naturalHeight || parseInt(this.style.height) || 500;
                
                // æ›´æ–°åˆ†è¾¨ç‡æ˜¾ç¤º
                const resolutionText = `${actualWidth}x${actualHeight}`;
                const resolutionElement = node.querySelector('.node-resolution');
                if (resolutionElement) {
                    resolutionElement.textContent = resolutionText;
                }
                
                // æ›´æ–°èŠ‚ç‚¹æ•°æ®
                node.dataset.width = actualWidth;
                node.dataset.height = actualHeight;
                
                // æ›´æ–°å›¾ç‰‡ä¸­å¿ƒåæ ‡
                updateImageCenterCoordinates(node);
                
                // æ›´æ–°ç¼©ç•¥å›¾
                updateMinimapWithImage(node);
            };
            
            // æ’å…¥å›¾ç‰‡ã€è°ƒæ•´å¤§å°æ‰‹æŸ„å’Œä¸­å¿ƒåæ ‡
            const header = node.querySelector('.node-header');
            const toolbar = node.querySelector('.node-toolbar');
            const infoElement = node.querySelector('.node-info');
            
            if (header && toolbar && infoElement) {
                // æ¸…ç©ºèŠ‚ç‚¹å†…å®¹ï¼Œä¿ç•™å¤´éƒ¨å’Œå·¥å…·æ 
                const children = [...node.children];
                children.forEach(child => {
                    if (child !== header && child !== toolbar && child !== infoElement) {
                        child.remove();
                    }
                });
                
                // æ’å…¥å›¾ç‰‡ã€è°ƒæ•´å¤§å°æ‰‹æŸ„å’Œä¸­å¿ƒåæ ‡
                node.insertBefore(img, infoElement);
                node.insertBefore(resizeHandle, infoElement);
                node.insertBefore(centerCoords, infoElement);
            }
            
            // æ·»åŠ è°ƒæ•´å¤§å°åŠŸèƒ½
            resizeHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                AppState.isResizingNode = true;
                AppState.resizeNode = node;
                AppState.resizeStart = {
                    x: e.clientX,
                    y: e.clientY,
                    width: img.width,
                    height: img.height
                };
                document.body.style.cursor = 'nwse-resize';
            });
            
            // æ·»åŠ å³é”®èœå•åŠŸèƒ½
            node.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const img = node.querySelector('img');
                showImageContextMenu(e, node, img);
            });
            
            // æ·»åŠ PINåŠŸèƒ½
            img.addEventListener('click', (e) => {
                e.stopPropagation();
                if (e.ctrlKey || e.metaKey) {
                    if (node.classList.contains('selected')) {
                        addPinToImage(node, e);
                    }
                }
            });
            
            // åˆå§‹åŒ–PINæ•°æ®
            node.dataset.pins = JSON.stringify([]);
            
            // é€‰ä¸­èŠ‚ç‚¹
            selectNode(node);
            
            // æ›´æ–°ç¼©ç•¥å›¾
            updateMinimapWithImage(node);
            
            return node;
        }
        
        function openModal(blobUrl) {
            currentBlobUrl = blobUrl;
            modalImage.src = blobUrl;
            imageModal.classList.remove('hidden');
            imageModal.classList.add('flex');
        }

        function closeModal() {
            imageModal.classList.add('hidden');
            imageModal.classList.remove('flex');
        }

        closeModalBtn.addEventListener('click', closeModal);
        closeModalBtn2.addEventListener('click', closeModal);
        imageModal.addEventListener('click', (e) => {
            if (e.target === imageModal) {
                closeModal();
            }
        });

        downloadModalBtn.addEventListener('click', () => {
            if (currentBlobUrl) {
                const link = document.createElement('a');
                link.href = currentBlobUrl;
                link.download = `gemini-generated-${Date.now()}.png`;
                link.click();
            }
        });

        openFolderBtn.addEventListener('click', async () => {
            try {
                const response = await fetch('/open-folder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                const result = await response.json();
                if (result.success) {
                    alert(`${result.message}\n\nè¯·å¤åˆ¶è·¯å¾„å¹¶åœ¨æ–‡ä»¶èµ„æºç®¡ç†å™¨ä¸­æ‰“å¼€`);
                    navigator.clipboard.writeText(result.path).then(() => {
                        console.log('è·¯å¾„å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                    });
                } else {
                    alert('æ‰“å¼€æ–‡ä»¶å¤¹å¤±è´¥: ' + result.error);
                }
            } catch (error) {
                alert('æ‰“å¼€æ–‡ä»¶å¤¹å¤±è´¥: ' + error.message);
            }
        });

        apiKeyInput.value = CONFIG.API_KEY;

        function populateModelSelects() {
            TEXT_MODELS.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                if (model.value === CONFIG.MODEL_NAME) {
                    option.selected = true;
                }
                textModelName.appendChild(option);
                
                const visionOption = document.createElement('option');
                visionOption.value = model.value;
                visionOption.textContent = model.name;
                if (model.value === CONFIG.MODEL_NAME) {
                    visionOption.selected = true;
                }
                visionModelName.appendChild(visionOption);
            });

            IMAGE_MODELS.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                if (model.value === CONFIG.IMAGE_MODEL_NAME) {
                    option.selected = true;
                }
                imageModelName.appendChild(option);
            });
        }

        populateModelSelects();

        let imageDataList = [];
        let pasteImageCounter = 0;

        function createImageTag(imageData, index) {
            const item = document.createElement('span');
            item.className = 'pasted-image-item';
            item.style.position = 'relative';
            item.dataset.index = index;
            item.dataset.imageUrl = imageData.data;
            item.dataset.filename = imageData.name;
            item.contentEditable = 'false';
            
            const img = document.createElement('img');
            img.src = imageData.data;
            img.alt = imageData.name;
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = imageData.name.length > 20 ? imageData.name.substring(0, 20) + '...' : imageData.name;
            nameSpan.title = imageData.name;
            
            const tooltip = document.createElement('div');
            tooltip.className = 'image-preview-tooltip';
            
            const tooltipImg = document.createElement('img');
            tooltipImg.src = imageData.data;
            tooltipImg.alt = imageData.name;
            
            // æ·»åŠ å›¾ç‰‡åŠ è½½å®Œæˆåçš„å°ºå¯¸è°ƒæ•´
            tooltipImg.onload = function() {
                const naturalWidth = this.naturalWidth;
                const naturalHeight = this.naturalHeight;
                
                const maxWidth = Math.min(window.innerWidth * 0.7, 500);
                const maxHeight = Math.min(window.innerHeight * 0.7, 500);
                
                const widthRatio = maxWidth / naturalWidth;
                const heightRatio = maxHeight / naturalHeight;
                const scale = Math.min(widthRatio, heightRatio);
                
                const displayWidth = naturalWidth * scale;
                const displayHeight = naturalHeight * scale;
                
                this.style.width = `${displayWidth}px`;
                this.style.height = `${displayHeight}px`;
            };
            
            tooltip.appendChild(tooltipImg);
            
            item.appendChild(img);
            item.appendChild(nameSpan);
            
            // å°† tooltip æŒ‚è½½åˆ°æœ€å¤–å±‚ body
            document.body.appendChild(tooltip);
            
            // ç”¨ JS ä¾¦å¬é¼ æ ‡æ‚¬åœï¼Œæ§åˆ¶æ˜¾ç¤ºå¹¶è§¦å‘å®šä½
            item.addEventListener('mouseenter', () => {
                tooltip.style.display = 'block';
                // å»¶è¿Ÿ 10ms ç¡®ä¿ DOM æ¸²æŸ“æ‹¿åˆ°çœŸå®å®½é«˜
                setTimeout(() => adjustTooltipPosition(tooltip, item), 10);
            });
            item.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
            
            // ä¿®æ”¹åˆ é™¤é€»è¾‘ï¼Œè¿åŒå¤–å±‚çš„ tooltip ä¸€èµ·åˆ æ‰
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'Ã—';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                const filename = item.dataset.filename;
                tooltip.remove(); // æ¸…ç†æ¸¸ç¦»çš„å¼¹çª—
                item.remove();
                updateImageDataList();
                debugLog(`[åˆ é™¤å›¾ç‰‡] æ–‡ä»¶å: ${filename}`, 'info');
            };
            
            item.appendChild(deleteBtn);
            
            return item;
        }

        function insertImageToPrompt(imageUrl, filename) {
            const imageData = {
                data: imageUrl,
                name: filename
            };
            imageDataList.push(imageData);
            const imageTag = createImageTag(imageData, pasteImageCounter++);
            promptInput.appendChild(imageTag);
            updateImageDataList();
            debugLog(`[æ’å…¥å›¾ç‰‡] æ–‡ä»¶å: ${filename}`, 'info');
        }

        promptInput.addEventListener('paste', async (e) => {
            debugLog(`[ç²˜è´´äº‹ä»¶] è§¦å‘, ç›®æ ‡: ${e.target.id || e.target.className}`, 'info');
            const items = e.clipboardData.items;
            debugLog(`[ç²˜è´´äº‹ä»¶] å‰ªè´´æ¿é¡¹ç›®æ•°é‡: ${items.length}`, 'info');
            
            for (let item of items) {
                debugLog(`[ç²˜è´´äº‹ä»¶] é¡¹ç›®ç±»å‹: ${item.type}`, 'info');
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    
                    const file = item.getAsFile();
                    debugLog(`[ç²˜è´´äº‹ä»¶] æ£€æµ‹åˆ°å›¾ç‰‡, æ–‡ä»¶å: ${file.name || 'æœªçŸ¥'}, ç±»å‹: ${file.type}, å¤§å°: ${file.size} bytes`, 'info');
                    
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const base64Data = event.target.result;
                        const baseName = file.name || 'image.png';
                        const ext = baseName.includes('.') ? baseName.split('.').pop() : 'png';
                        const uniqueName = `image_${pasteImageCounter + 1}.${ext}`;
                        
                        debugLog(`[ç²˜è´´å›¾ç‰‡] Base64é•¿åº¦: ${base64Data.length}, å‰50å­—ç¬¦: ${base64Data.substring(0, 50)}`, 'info');
                        
                        const imageData = {
                            data: base64Data,
                            name: uniqueName
                        };
                        
                        const imageTag = createImageTag(imageData, imageDataList.length);
                        insertAtCursor(imageTag);
                        updateImageDataList();
                        
                        pasteImageCounter++;
                        
                        debugLog(`[ç²˜è´´å›¾ç‰‡] æ–‡ä»¶å: ${uniqueName}, æ¥æº: å‰ªè´´æ¿`, 'info');
                    };
                    
                    reader.readAsDataURL(file);
                }
            }
        });
        
        document.addEventListener('paste', (e) => {
            if (!imageGenMode.checked) return;
            
            const isInInput = document.activeElement === promptInput || promptInput.contains(document.activeElement);
            if (isInInput) return;
            
            debugLog(`[ç”»å¸ƒç²˜è´´] è§¦å‘, ç›®æ ‡: ${e.target.id || e.target.className}`, 'info');
            
            const items = e.clipboardData.items;
            let hasImage = false;
            
            for (let item of items) {
                debugLog(`[ç”»å¸ƒç²˜è´´] é¡¹ç›®ç±»å‹: ${item.type}`, 'info');
                if (item.type.indexOf('image') !== -1) {
                    hasImage = true;
                    e.preventDefault();
                    
                    const file = item.getAsFile();
                    debugLog(`[ç”»å¸ƒç²˜è´´] æ£€æµ‹åˆ°å›¾ç‰‡, æ–‡ä»¶å: ${file.name || 'æœªçŸ¥'}, ç±»å‹: ${file.type}, å¤§å°: ${file.size} bytes`, 'info');
                    
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const base64Data = event.target.result;
                        const baseName = file.name || 'image.png';
                        const ext = baseName.includes('.') ? baseName.split('.').pop() : 'png';
                        const uniqueName = `pasted_${Date.now()}.${ext}`;
                        
                        debugLog(`[ç”»å¸ƒç²˜è´´] åˆ›å»ºèŠ‚ç‚¹: ${uniqueName}`, 'info');
                        
                        const node = createImageNode(base64Data, 'ç²˜è´´å›¾ç‰‡', nodeCounter++, uniqueName, `${file.width || 500}x${file.height || 500}`);
                        imageResponseContainer.appendChild(node);
                        
                        debugLog(`[ç²˜è´´] å›¾ç‰‡: ${uniqueName}`, 'info');
                    };
                    
                    reader.readAsDataURL(file);
                    break;
                }
            }
            
            if (!hasImage && clipboardNode) {
                e.preventDefault();
                debugLog(`[ç”»å¸ƒç²˜è´´] ä½¿ç”¨clipboardNode: ${clipboardNode.dataset.filename}`, 'info');
                pasteNode();
            }
        });

        function insertAtCursor(node) {
            const selection = window.getSelection();
            
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                
                const parent = promptInput;
                if (parent.contains(range.commonAncestorContainer) || parent === range.commonAncestorContainer) {
                    range.deleteContents();
                    
                    const spaceBefore = document.createTextNode(' ');
                    const spaceAfter = document.createTextNode(' ');
                    
                    range.insertNode(spaceBefore);
                    range.insertNode(node);
                    range.insertNode(spaceAfter);
                    
                    const newRange = document.createRange();
                    newRange.setStartAfter(node);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                } else {
                    const spaceBefore = document.createTextNode(' ');
                    const spaceAfter = document.createTextNode(' ');
                    promptInput.appendChild(spaceBefore);
                    promptInput.appendChild(node);
                    promptInput.appendChild(spaceAfter);
                    
                    const newRange = document.createRange();
                    newRange.setStartAfter(node);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            } else {
                const spaceBefore = document.createTextNode(' ');
                const spaceAfter = document.createTextNode(' ');
                promptInput.appendChild(spaceBefore);
                promptInput.appendChild(node);
                promptInput.appendChild(spaceAfter);
                
                const newRange = document.createRange();
                newRange.setStartAfter(node);
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
            
            promptInput.focus();
        }

        function updateImageDataList() {
            imageDataList = [];
            const imageTags = promptInput.querySelectorAll('.pasted-image-item');
            imageTags.forEach((tag, index) => {
                imageDataList.push({
                    data: tag.dataset.imageUrl,
                    name: tag.dataset.filename
                });
                tag.dataset.index = index;
            });
        }

        function addCanvasImageToPrompt(node) {
            const imageUrl = node.dataset.imageUrl;
            const filename = node.dataset.filename;
            
            if (!imageUrl || node.classList.contains('loading-placeholder') || filename === 'Loading...') {
                alert('æ— æ³•æ’å…¥æ­£åœ¨ç”Ÿæˆçš„å›¾ç‰‡ï¼Œè¯·ç­‰å¾…å›¾ç‰‡ç”Ÿæˆå®Œæˆåå†è¯•');
                return;
            }
            
            const existingTags = promptInput.querySelectorAll('.pasted-image-item');
            for (let tag of existingTags) {
                if (tag.dataset.imageUrl === imageUrl) {
                    return;
                }
            }
            
            const img = node.querySelector('img');
            if (!img) {
                alert('æ— æ³•è·å–å›¾ç‰‡æ•°æ®');
                return;
            }
            
            let imageDataUrl;
            if (img.src.startsWith('data:')) {
                imageDataUrl = img.src;
            } else {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.naturalWidth || img.width;
                canvas.height = img.naturalHeight || img.height;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                imageDataUrl = canvas.toDataURL('image/png');
            }
            
            const imageData = {
                data: imageDataUrl,
                name: filename
            };
            
            const imageTag = createImageTag(imageData, imageDataList.length);
            insertAtCursor(imageTag);
            updateImageDataList();
            
            debugLog(`[æ’å…¥å›¾ç‰‡] æ–‡ä»¶å: ${filename}, æ•°æ®æ ¼å¼: ${imageDataUrl.startsWith('data:') ? 'Base64' : 'URL'}`, 'info');
        }

        async function drawPinsOnImage(imageUrl, pins) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth || img.width;
                    canvas.height = img.naturalHeight || img.height;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    pins.forEach(pin => {
                        const x = pin.x;
                        const y = pin.y;
                        const radius = Math.max(20, Math.min(canvas.width, canvas.height) / 30);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        ctx.font = `bold ${radius}px Arial`;
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(pin.number.toString(), x, y);
                    });
                    
                    const annotatedImageUrl = canvas.toDataURL('image/png');
                    resolve(annotatedImageUrl);
                };
                img.onerror = () => {
                    resolve(imageUrl);
                };
                img.src = imageUrl;
            });
        }

        function addPinToImage(node, event) {
            const img = node.querySelector('img');
            const rect = img.getBoundingClientRect();
            
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            
            const x = ((event.clientX - rect.left) / rect.width) * naturalWidth;
            const y = ((event.clientY - rect.top) / rect.height) * naturalHeight;
            
            const pins = JSON.parse(node.dataset.pins || '[]');
            
            let availableNumber = 1;
            const existingNumbers = new Set(pins.map(p => p.number));
            while (existingNumbers.has(availableNumber)) {
                availableNumber++;
            }
            
            const pin = { id: Date.now(), number: availableNumber, x: x, y: y };
            pins.push(pin);
            pins.sort((a, b) => a.number - b.number);
            node.dataset.pins = JSON.stringify(pins);
            
            createPinMarker(node, pin);
            updatePromptWithPins(node);
            
            debugLog(`[æ·»åŠ PIN] åæ ‡: (${Math.round(x)}, ${Math.round(y)})`, 'info');
        }

        function createPinMarker(node, pin) {
            const img = node.querySelector('img');
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            
            const logicalWidth = img.offsetWidth;
            const logicalHeight = img.offsetHeight;
            
            const scaleX = logicalWidth / naturalWidth;
            const scaleY = logicalHeight / naturalHeight;
            
            const displayX = pin.x * scaleX;
            const displayY = pin.y * scaleY;
            
            const marker = document.createElement('div');
            marker.className = 'pin-marker';
            marker.dataset.pinId = pin.id;
            marker.textContent = pin.number;
            
            marker.style.left = `${displayX - 12}px`;
            marker.style.top = `${displayY - 12}px`;
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'pin-delete';
            deleteBtn.textContent = 'Ã—';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removePinFromImage(node, pin.id);
            });
            
            marker.appendChild(deleteBtn);
            node.appendChild(marker);
        }

        function refreshPinsOnNode(node) {
            const pins = JSON.parse(node.dataset.pins || '[]');
            const img = node.querySelector('img');
            if (!img || pins.length === 0) return;
            
            const scaleX = img.offsetWidth / img.naturalWidth;
            const scaleY = img.offsetHeight / img.naturalHeight;

            pins.forEach(pin => {
                const marker = node.querySelector(`.pin-marker[data-pin-id="${pin.id}"]`);
                if (marker) {
                    marker.style.left = `${(pin.x * scaleX) - 12}px`;
                    marker.style.top = `${(pin.y * scaleY) - 12}px`;
                }
            });
        }

        function removePinFromImage(node, pinId) {
            const pins = JSON.parse(node.dataset.pins || '[]');
            const index = pins.findIndex(p => p.id === pinId);
            
            if (index !== -1) {
                const pin = pins[index];
                pins.splice(index, 1);
                node.dataset.pins = JSON.stringify(pins);
                
                const marker = node.querySelector(`.pin-marker[data-pin-id="${pinId}"]`);
                if (marker) {
                    marker.remove();
                }
                
                const tag = promptInput.querySelector(`.pinned-image-tag[data-image-url="${node.dataset.imageUrl}"][data-pin-number="${pin.number}"]`);
                if (tag) {
                    tag.remove();
                }
                
                debugLog(`[åˆ é™¤PIN] å›¾ç‰‡: ${node.dataset.filename}, PINç¼–å·: ${pin.number}`, 'info');
            }
        }

        function updatePromptWithPins(node) {
            const pins = JSON.parse(node.dataset.pins || '[]');
            const imageUrl = node.dataset.imageUrl;
            const filename = node.dataset.filename;
            
            const existingTags = promptInput.querySelectorAll('.pinned-image-tag');
            const existingPinNumbers = new Set();
            existingTags.forEach(tag => {
                if (tag.dataset.imageUrl === imageUrl) {
                    existingPinNumbers.add(parseInt(tag.dataset.pinNumber));
                }
            });
            
            pins.forEach(pin => {
                if (!existingPinNumbers.has(pin.number)) {
                    const tag = createPinnedImageTag(imageUrl, filename, pin.number, pin.x, pin.y);
                    insertAtCursor(tag);
                }
            });
        }

        function createPinnedImageTag(imageUrl, filename, pinNumber, pinX, pinY) {
            const tag = document.createElement('span');
            tag.className = 'pinned-image-tag';
            tag.dataset.imageUrl = imageUrl;
            tag.dataset.pinNumber = pinNumber;
            tag.contentEditable = 'false';
            tag.style.userSelect = 'none';
            
            const thumbnail = document.createElement('img');
            thumbnail.src = imageUrl;
            thumbnail.style.width = '24px';
            thumbnail.style.height = '24px';
            thumbnail.style.objectFit = 'cover';
            thumbnail.style.borderRadius = '4px';
            
            const numberBadge = document.createElement('span');
            numberBadge.className = 'pin-number';
            numberBadge.textContent = pinNumber;
            
            const label = document.createElement('span');
            label.className = 'pin-filename';
            label.textContent = `${filename}[${pinNumber}]`;
            
            const tooltip = document.createElement('div');
            tooltip.className = 'image-preview-tooltip';
            
            const tooltipImg = document.createElement('img');
            tooltipImg.src = imageUrl;
            
            const pinIndicator = document.createElement('div');
            pinIndicator.className = 'pin-indicator';
            pinIndicator.textContent = pinNumber;
            
            if (pinX !== undefined && pinY !== undefined) {
                tooltipImg.onload = function() {
                    const naturalWidth = this.naturalWidth;
                    const naturalHeight = this.naturalHeight;
                    
                    const maxWidth = Math.min(window.innerWidth * 0.7, 500);
                    const maxHeight = Math.min(window.innerHeight * 0.7, 500);
                    
                    const widthRatio = maxWidth / naturalWidth;
                    const heightRatio = maxHeight / naturalHeight;
                    const scale = Math.min(widthRatio, heightRatio);
                    
                    const displayWidth = naturalWidth * scale;
                    const displayHeight = naturalHeight * scale;
                    
                    this.style.width = `${displayWidth}px`;
                    this.style.height = `${displayHeight}px`;
                    
                    const indicatorX = pinX * scale;
                    const indicatorY = pinY * scale;
                    
                    pinIndicator.style.left = `${indicatorX}px`;
                    pinIndicator.style.top = `${indicatorY}px`;
                };
            } else {
                tooltipImg.onload = function() {
                    const naturalWidth = this.naturalWidth;
                    const naturalHeight = this.naturalHeight;
                    
                    const maxWidth = Math.min(window.innerWidth * 0.7, 500);
                    const maxHeight = Math.min(window.innerHeight * 0.7, 500);
                    
                    const widthRatio = maxWidth / naturalWidth;
                    const heightRatio = maxHeight / naturalHeight;
                    const scale = Math.min(widthRatio, heightRatio);
                    
                    const displayWidth = naturalWidth * scale;
                    const displayHeight = naturalHeight * scale;
                    
                    this.style.width = `${displayWidth}px`;
                    this.style.height = `${displayHeight}px`;
                };
            }
            
            tooltip.appendChild(tooltipImg);
            tooltip.appendChild(pinIndicator);
            
            tag.appendChild(thumbnail);
            tag.appendChild(numberBadge);
            tag.appendChild(label);
            
            // å°† tooltip æŒ‚è½½åˆ°æœ€å¤–å±‚ body
            document.body.appendChild(tooltip);
            
            // ç”¨ JS ä¾¦å¬é¼ æ ‡æ‚¬åœï¼Œæ§åˆ¶æ˜¾ç¤ºå¹¶è§¦å‘å®šä½
            tag.addEventListener('mouseenter', () => {
                tooltip.style.display = 'block';
                // å»¶è¿Ÿ 10ms ç¡®ä¿ DOM æ¸²æŸ“æ‹¿åˆ°çœŸå®å®½é«˜
                setTimeout(() => adjustTooltipPosition(tooltip, tag), 10);
            });
            tag.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
            
            // ä¿®æ”¹åˆ é™¤é€»è¾‘ï¼Œè¿åŒå¤–å±‚çš„ tooltip ä¸€èµ·åˆ æ‰
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'tag-delete';
            deleteBtn.textContent = 'Ã—';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const node = findNodeByImageUrl(imageUrl);
                if (node) {
                    const pins = JSON.parse(node.dataset.pins || '[]');
                    const pin = pins.find(p => p.number === pinNumber);
                    if (pin) {
                        const marker = node.querySelector(`.pin-marker[data-pin-id="${pin.id}"]`);
                        if (marker) {
                            marker.remove();
                        }
                        pins.splice(pins.indexOf(pin), 1);
                        node.dataset.pins = JSON.stringify(pins);
                    }
                }
                tooltip.remove(); // æ¸…ç†æ¸¸ç¦»çš„å¼¹çª—
                tag.remove();
            });
            
            tag.appendChild(deleteBtn);
            
            return tag;
        }

        function findNodeByImageUrl(imageUrl) {
            const nodes = imageResponseContainer.querySelectorAll('.canvas-node');
            for (let node of nodes) {
                if (node.dataset.imageUrl === imageUrl) {
                    return node;
                }
            }
            return null;
        }

        function showImageContextMenu(e, node, img) {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;
            
            const copyItem = document.createElement('div');
            copyItem.className = 'context-menu-item';
            copyItem.textContent = 'å¤åˆ¶å›¾ç‰‡';
            copyItem.addEventListener('click', () => {
                if (img.src.startsWith('data:')) {
                    navigator.clipboard.writeText(img.src).then(() => {
                        console.log('å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                    });
                } else {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth || img.width;
                    canvas.height = img.naturalHeight || img.height;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    canvas.toBlob((blob) => {
                        navigator.clipboard.write([
                            new ClipboardItem({
                                'image/png': blob
                            })
                        ]).then(() => {
                            console.log('å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        }).catch(err => {
                            console.error('å¤åˆ¶å¤±è´¥:', err);
                        });
                    });
                }
                menu.remove();
            });
            
            const downloadItem = document.createElement('div');
            downloadItem.className = 'context-menu-item';
            downloadItem.textContent = 'ä¸‹è½½å›¾ç‰‡';
            downloadItem.addEventListener('click', () => {
                const filename = node.dataset.filename || 'image.png';
                const link = document.createElement('a');
                link.href = img.src;
                link.download = filename;
                link.click();
                menu.remove();
            });
            
            const insertItem = document.createElement('div');
            insertItem.className = 'context-menu-item';
            insertItem.textContent = 'æ’å…¥åˆ°è¾“å…¥æ¡†';
            insertItem.addEventListener('click', () => {
                addCanvasImageToPrompt(node);
                menu.remove();
            });
            
            menu.appendChild(copyItem);
            menu.appendChild(downloadItem);
            menu.appendChild(insertItem);
            document.body.appendChild(menu);
            
            setTimeout(() => {
                document.addEventListener('click', (clickEvent) => {
                    if (!menu.contains(clickEvent.target)) {
                        menu.remove();
                    }
                }, { once: true });
            }, 100);
        }

        function adjustTooltipPosition(tooltip, targetElement) {
            if (!tooltip || !targetElement) return;
            
            // è·å–è¾“å…¥æ¡†æ ‡ç­¾çš„ç»å¯¹ä½ç½®
            const targetRect = targetElement.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // è·å–é¢„è§ˆå›¾çš„å®é™…å®½é«˜
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width || 300;
            const tooltipHeight = tooltipRect.height || 300;
            
            // æ ¸å¿ƒé€»è¾‘ï¼šå¼ºåˆ¶é å·¦ - æ ‡ç­¾å·¦è¾¹ç¼˜ å‡å» é¢„è§ˆå›¾å®½åº¦ å‡å» 12px é—´è·
            let left = targetRect.left - tooltipWidth - 12;
            
            // å‚ç›´æ–¹å‘ï¼šä¸æ ‡ç­¾å±…ä¸­å¯¹é½
            let top = targetRect.top + (targetRect.height / 2) - (tooltipHeight / 2);
            
            // é˜²ç¿»è½¦è¾¹ç•Œæ£€æµ‹
            if (left < 10) {
                // å¦‚æœå·¦è¾¹å±å¹•ç©ºé—´ä¸å¤Ÿï¼Œå¦¥åä¸€ä¸‹æ”¾åˆ°å³è¾¹
                left = targetRect.right + 12;
            }
            if (top < 10) top = 10;
            if (top + tooltipHeight > windowHeight - 10) {
                top = windowHeight - tooltipHeight - 10;
            }
            
            // åº”ç”¨æœ€ç»ˆåæ ‡
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        imageGenMode.addEventListener('change', () => {
            console.log('Image gen mode changed:', imageGenMode.checked);
            if (imageGenMode.checked) {
                imageResponseContainer.style.display = 'block';
                responseOutput.style.display = 'none';
            } else {
                imageResponseContainer.style.display = 'block';
                responseOutput.style.display = 'none';
            }
        });

        if (imageGenMode.checked) {
            imageResponseContainer.style.display = 'block';
            responseOutput.style.display = 'none';
        } else {
            imageResponseContainer.style.display = 'block';
            responseOutput.style.display = 'none';
        }

        temperature.addEventListener('input', () => {
            temperatureValue.textContent = temperature.value;
        });

        topP.addEventListener('input', () => {
            topPValue.textContent = topP.value;
        });

        async function testApiKey() {
            const apiKey = CONFIG.API_KEY.trim();
            
            if (!apiKey || apiKey === "YOUR_API_KEY_HERE") {
                apiStatus.innerHTML = '<span class="text-red-600">è¯·è¾“å…¥æœ‰æ•ˆçš„ API Key</span>';
                return;
            }

            testApiKeyBtn.disabled = true;
            testLoader.classList.remove('hidden');
            apiStatus.innerHTML = '<span class="text-blue-600">æ­£åœ¨éªŒè¯ API Key...</span>';

            try {
                const genAI = new GoogleGenerativeAI(apiKey);
                const model = genAI.getGenerativeModel({ model: CONFIG.MODEL_NAME });
                
                const result = await model.generateContent("test");
                await result.response;
                
                apiStatus.innerHTML = '<span class="text-green-600">âœ“ API Key éªŒè¯æˆåŠŸ</span>';
            } catch (error) {
                console.error(error);
                apiStatus.innerHTML = '<span class="text-red-600">âœ— API Key æ— æ•ˆ: ' + error.message + '</span>';
            } finally {
                testApiKeyBtn.disabled = false;
                testLoader.classList.add('hidden');
            }
        }

        async function saveApiKey() {
            const apiKey = CONFIG.API_KEY.trim();
            
            if (!apiKey || apiKey === "YOUR_API_KEY_HERE") {
                apiStatus.innerHTML = '<span class="text-red-600">è¯·è¾“å…¥æœ‰æ•ˆçš„ API Key</span>';
                return;
            }

            try {
                const saveEnvResponse = await fetch('/save-env', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        apiKey: apiKey,
                        modelName: textModelName.value,
                        imageModelName: imageModelName.value
                    })
                });
                
                const saveEnvResult = await saveEnvResponse.json();
                
                if (saveEnvResult.success) {
                    const reloadEnvResponse = await fetch('/reload-env', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const reloadEnvResult = await reloadEnvResponse.json();
                    
                    if (reloadEnvResult.success) {
                        CONFIG.API_KEY = apiKey;
                        CONFIG.MODEL_NAME = textModelName.value;
                        CONFIG.IMAGE_MODEL_NAME = imageModelName.value;
                        apiStatus.innerHTML = '<span class="text-green-600">âœ“ API Key å·²ä¿å­˜åˆ°æœåŠ¡å™¨</span>';
                    } else {
                        apiStatus.innerHTML = '<span class="text-yellow-600">âœ“ API Key å·²ä¿å­˜ï¼Œä½†ç¯å¢ƒå˜é‡é‡è½½å¤±è´¥: ' + reloadEnvResult.error + '</span>';
                    }
                } else {
                    apiStatus.innerHTML = '<span class="text-red-600">âœ— ä¿å­˜å¤±è´¥: ' + saveEnvResult.error + '</span>';
                }
            } catch (error) {
                console.error(error);
                apiStatus.innerHTML = '<span class="text-red-600">âœ— ä¿å­˜å¤±è´¥: ' + error.message + '</span>';
            }
        }

        async function clearApiKey() {
            try {
                const clearEnvResponse = await fetch('/clear-env', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const clearEnvResult = await clearEnvResponse.json();
                
                if (clearEnvResult.success) {
                    CONFIG.API_KEY = '';
                    CONFIG.MODEL_NAME = 'gemini-3-flash-preview';
                    CONFIG.IMAGE_MODEL_NAME = 'gemini-3-pro-image-preview';
                    apiKeyInput.value = '';
                    apiStatus.innerHTML = '<span class="text-green-600">âœ“ API Key å·²ä»æœåŠ¡å™¨æ¸…é™¤</span>';
                } else {
                    apiStatus.innerHTML = '<span class="text-red-600">âœ— æ¸…é™¤å¤±è´¥: ' + clearEnvResult.error + '</span>';
                }
            } catch (error) {
                console.error(error);
                apiStatus.innerHTML = '<span class="text-red-600">âœ— æ¸…é™¤å¤±è´¥: ' + error.message + '</span>';
            }
        }

        testApiKeyBtn.addEventListener('click', testApiKey);
        document.getElementById('saveApiKeyBtn').addEventListener('click', saveApiKey);
        document.getElementById('clearApiKeyBtn').addEventListener('click', clearApiKey);

        async function callAPI() {
            debugLog(`[å¼€å§‹è°ƒç”¨] callAPI å‡½æ•°`, 'info');
            
            updateImageDataList();
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = promptInput.innerHTML;
            const imageTags = tempDiv.querySelectorAll('.pasted-image-item');
            imageTags.forEach(tag => tag.remove());
            
            const pinnedImageTags = tempDiv.querySelectorAll('.pinned-image-tag');
            let processedPrompt = tempDiv.textContent.trim();
            
            const pinInfo = [];
            pinnedImageTags.forEach(tag => {
                const imageUrl = tag.dataset.imageUrl;
                const pinNumber = tag.dataset.pinNumber;
                const filename = tag.querySelector('.pin-filename').textContent;
                
                const node = findNodeByImageUrl(imageUrl);
                if (node) {
                    const pins = JSON.parse(node.dataset.pins || '[]');
                    const pin = pins.find(p => p.number == pinNumber);
                    if (pin) {
                        pinInfo.push({
                            imageUrl: imageUrl,
                            pinNumber: pinNumber,
                            filename: filename,
                            x: pin.x,
                            y: pin.y
                        });
                    }
                }
            });
            
            if (pinInfo.length > 0) {
                pinInfo.forEach(info => {
                    const pinTag = `[${info.pinNumber}]`;
                    if (processedPrompt.includes(pinTag)) {
                        processedPrompt = processedPrompt.replace(pinTag, `[å›¾ç‰‡ä¸­ PIN ${info.pinNumber} æ ‡è®°çš„ä½ç½®]`);
                    }
                });
            }
            
            const prompt = processedPrompt;
            const apiKey = CONFIG.API_KEY.trim();
            const isImageGenMode = imageGenMode.checked;
            
            debugLog(`[å‚æ•°æ£€æŸ¥] æç¤ºè¯: "${prompt}", ç”Ÿå›¾æ¨¡å¼: ${isImageGenMode}, å›¾ç‰‡æ•°é‡: ${imageDataList.length}, PINæ•°é‡: ${pinInfo.length}`, 'info');
            debugLog(`[API Key] ${apiKey.substring(0, 10)}...`, 'info');
            
            if (!prompt && imageDataList.length === 0 && pinInfo.length === 0) {
                debugLog(`[é”™è¯¯] è¯·è¾“å…¥å†…å®¹æˆ–ç²˜è´´å›¾ç‰‡`, 'error');
                return alert("è¯·è¾“å…¥å†…å®¹æˆ–ç²˜è´´å›¾ç‰‡");
            }
            if (!apiKey || apiKey === "YOUR_API_KEY_HERE") {
                debugLog(`[é”™è¯¯] è¯·è¾“å…¥æœ‰æ•ˆçš„ API Key`, 'error');
                return alert("è¯·è¾“å…¥æœ‰æ•ˆçš„ API Key");
            }

            const genAI = new GoogleGenerativeAI(apiKey);
            
            let modelName;
            if (isImageGenMode) {
                modelName = imageModelName.value;
            } else if (imageDataList.length > 0) {
                modelName = visionModelName.value;
            } else {
                modelName = textModelName.value;
            }
            
            const generationConfig = {
                temperature: parseFloat(temperature.value),
                topP: parseFloat(topP.value),
                topK: 40,
                maxOutputTokens: 8192
            };
            
            if (isImageGenMode) {
                generationConfig.imageConfig = {
                    aspectRatio: aspectRatio.value,
                    imageSize: imageSize.value
                };
            }
            
            const model = genAI.getGenerativeModel({ 
                model: modelName,
                generationConfig: generationConfig
            });

            debugLog(`[æ¨¡å‹é…ç½®] æ¨¡å‹: ${modelName}, æ¸©åº¦: ${generationConfig.temperature}, TopP: ${generationConfig.topP}`, 'info');
            
            activeRequests++;
            if (activeRequests === 1) {
                loader.classList.remove('hidden');
                if (statusTag) {
                    statusTag.innerText = "è¯·æ±‚ä¸­";
                    statusTag.className = "text-xs px-2 py-1 rounded bg-blue-50 text-blue-600";
                }
            }
            debugLog(`[è¯·æ±‚çŠ¶æ€] æ´»è·ƒè¯·æ±‚æ•°: ${activeRequests}`, 'info');
            responseOutput.classList.remove('italic', 'text-gray-400');
            responseOutput.innerText = "æ­£åœ¨å¤„ç†...";
            imageResponseContainer.classList.remove('hidden');

            let loadingPlaceholder = null;
            if (isImageGenMode) {
                const aspectRatioValue = aspectRatio.value;
                const imageSizeValue = imageSize.value;
                
                let width, height;
                const baseSize = imageSizeValue === '1K' ? 1024 : imageSizeValue === '2K' ? 2048 : 4096;
                
                switch (aspectRatioValue) {
                    case '1:1':
                        width = baseSize;
                        height = baseSize;
                        break;
                    case '16:9':
                        width = baseSize;
                        height = Math.round(baseSize * 9 / 16);
                        break;
                    case '9:16':
                        width = Math.round(baseSize * 9 / 16);
                        height = baseSize;
                        break;
                    case '21:9':
                        width = baseSize;
                        height = Math.round(baseSize * 9 / 21);
                        break;
                    case '4:3':
                        width = baseSize;
                        height = Math.round(baseSize * 3 / 4);
                        break;
                    case '3:4':
                        width = Math.round(baseSize * 3 / 4);
                        height = baseSize;
                        break;
                    case '3:2':
                        width = baseSize;
                        height = Math.round(baseSize * 2 / 3);
                        break;
                    case '2:3':
                        width = Math.round(baseSize * 2 / 3);
                        height = baseSize;
                        break;
                    case '5:4':
                        width = baseSize;
                        height = Math.round(baseSize * 4 / 5);
                        break;
                    case '4:5':
                        width = Math.round(baseSize * 4 / 5);
                        height = baseSize;
                        break;
                    default:
                        width = baseSize;
                        height = Math.round(baseSize * 9 / 16);
                }
                
                const displayWidth = Math.min(width, 400);
                const displayHeight = Math.round(displayWidth * height / width);
                
                const existingNodes = imageResponseContainer.querySelectorAll('.canvas-node');
                let x = 5000;
                let y = 5000;
                
                if (existingNodes.length > 0) {
                    const lastNode = existingNodes[existingNodes.length - 1];
                    
                    const lastNodeX = parseInt(lastNode.style.left) || 0;
                    const lastNodeY = parseInt(lastNode.style.top) || 0;
                    const lastNodeWidth = lastNode.offsetWidth;
                    const lastNodeHeight = lastNode.offsetHeight;
                    
                    x = lastNodeX + lastNodeWidth + 50;
                    y = lastNodeY;
                    
                    if (x > 6000) {
                        x = 5000;
                        y = lastNodeY + lastNodeHeight + 50;
                    }
                }
                
                // åˆ›å»ºä¸€ä¸ªcanvas-nodeå…ƒç´ ä½œä¸ºå ä½ç¬¦
                loadingPlaceholder = createLoadingPlaceholder(displayWidth, displayHeight, x, y);
                imageResponseContainer.appendChild(loadingPlaceholder);
                
                // ç«‹å³æ›´æ–°ç¼©ç•¥å›¾ï¼Œæ˜¾ç¤ºå ä½ç¬¦
                updateMinimapWithImage(loadingPlaceholder);
            }

            try {
                let content;
                
                debugLog(`[APIè¯·æ±‚] æ¨¡å¼: ${isImageGenMode ? 'ç”Ÿå›¾' : 'æ–‡æœ¬'}, æç¤ºè¯: ${prompt}`, 'info');
                
                if (isImageGenMode) {
                    const allImageData = [...imageDataList];
                    
                    for (const info of pinInfo) {
                        const node = findNodeByImageUrl(info.imageUrl);
                        if (node) {
                            const img = node.querySelector('img');
                            const pins = JSON.parse(node.dataset.pins || '[]');
                            
                            let base64Data;
                            if (img.src.startsWith('data:')) {
                                base64Data = img.src;
                            } else {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.naturalWidth || img.width;
                                canvas.height = img.naturalHeight || img.height;
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                base64Data = canvas.toDataURL('image/png');
                            }
                            
                            if (pins.length > 0) {
                                debugLog(`[PINæ ‡è®°] åœ¨å›¾ç‰‡ä¸Šç»˜åˆ¶ ${pins.length} ä¸ªPINæ ‡è®°`, 'info');
                                base64Data = await drawPinsOnImage(base64Data, pins);
                            }
                            
                            const existing = allImageData.find(data => data.data === base64Data);
                            if (!existing) {
                                allImageData.push({
                                    data: base64Data,
                                    name: info.filename
                                });
                            }
                        }
                    }
                    
                    if (allImageData.length > 0) {
                        if (prompt) {
                            content = allImageData.map(imageData => ({
                                inlineData: { 
                                    data: imageData.data.split(',')[1], 
                                    mimeType: imageData.data.split(';')[0].split(':')[1] 
                                }
                            }));
                            const pinNote = pinInfo.length > 0 ? 'å®Œå…¨ç§»é™¤å›¾ç‰‡ä¸Šçš„æ‰€æœ‰çº¢è‰²æ•°å­—æ ‡è®°ï¼Œä¸è¦åœ¨ç”Ÿæˆçš„å›¾ç‰‡ä¸­æ˜¾ç¤ºä»»ä½•æ ‡è®°ã€‚' : '';
                            content.push(`${prompt}ï¼Œä½¿ç”¨${aspectRatio.value}å®½é«˜æ¯”ã€‚${pinNote}`);
                        } else {
                            content = allImageData.map(imageData => ({
                                inlineData: { 
                                    data: imageData.data.split(',')[1], 
                                    mimeType: imageData.data.split(';')[0].split(':')[1] 
                                }
                            }));
                            const pinNote = pinInfo.length > 0 ? 'å®Œå…¨ç§»é™¤å›¾ç‰‡ä¸Šçš„æ‰€æœ‰çº¢è‰²æ•°å­—æ ‡è®°ï¼Œä¸è¦åœ¨ç”Ÿæˆçš„å›¾ç‰‡ä¸­æ˜¾ç¤ºä»»ä½•æ ‡è®°ã€‚' : '';
                            content.push(`è¯·ç¾åŒ–è¿™å¼ å›¾ç‰‡ï¼Œä½¿ç”¨${aspectRatio.value}å®½é«˜æ¯”ã€‚${pinNote}`);
                        }
                    } else {
                        content = `${prompt}ï¼Œä½¿ç”¨${aspectRatio.value}å®½é«˜æ¯”`;
                    }
                } else {
                    const allImageData = [...imageDataList];
                    
                    for (const info of pinInfo) {
                        const node = findNodeByImageUrl(info.imageUrl);
                        if (node) {
                            const img = node.querySelector('img');
                            const pins = JSON.parse(node.dataset.pins || '[]');
                            
                            let base64Data;
                            if (img.src.startsWith('data:')) {
                                base64Data = img.src;
                            } else {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.naturalWidth || img.width;
                                canvas.height = img.naturalHeight || img.height;
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                base64Data = canvas.toDataURL('image/png');
                            }
                            
                            if (pins.length > 0) {
                                debugLog(`[PINæ ‡è®°] åœ¨å›¾ç‰‡ä¸Šç»˜åˆ¶ ${pins.length} ä¸ªPINæ ‡è®°`, 'info');
                                base64Data = await drawPinsOnImage(base64Data, pins);
                            }
                            
                            const existing = allImageData.find(data => data.data === base64Data);
                            if (!existing) {
                                allImageData.push({
                                    data: base64Data,
                                    name: info.filename
                                });
                            }
                        }
                    }
                    
                    if (allImageData.length > 0) {
                        content = allImageData.map(imageData => ({
                            inlineData: {
                                data: imageData.data.split(',')[1],
                                mimeType: imageData.data.split(';')[0].split(':')[1]
                            }
                        }));
                        content.push(`${prompt}`);
                    } else {
                        content = prompt;
                    }
                    
                    const existingNodes = imageResponseContainer.querySelectorAll('.canvas-node');
                    let x = 5000;
                    let y = 5000;
                    
                    if (existingNodes.length > 0) {
                        const lastNode = existingNodes[existingNodes.length - 1];
                        
                        const lastNodeX = parseInt(lastNode.style.left) || 0;
                        const lastNodeY = parseInt(lastNode.style.top) || 0;
                        const lastNodeWidth = lastNode.offsetWidth;
                        const lastNodeHeight = lastNode.offsetHeight;
                        
                        x = lastNodeX + lastNodeWidth + 50;
                        y = lastNodeY;
                        
                        if (x > 6000) {
                            x = 5000;
                            y = lastNodeY + lastNodeHeight + 50;
                        }
                    }
                    
                    loadingPlaceholder = createTextLoadingPlaceholder(prompt, x, y);
                    imageResponseContainer.appendChild(loadingPlaceholder);
                    updateMinimapWithImage(loadingPlaceholder);
                }
                
                const result = await model.generateContent(content);
                const response = await result.response;
                
                debugLog(`[APIå“åº”] æ”¶åˆ°å“åº”, å€™é€‰æ•°é‡: ${response.candidates?.length || 0}`, 'info');
                
                if (isImageGenMode) {
                    const imagePart = response.candidates[0]?.content?.parts.find(part => part.inlineData);
                    debugLog(`[ç”Ÿå›¾æ¨¡å¼] å›¾ç‰‡æ•°æ®: ${imagePart ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}`, 'info');
                    
                    if (imagePart) {
                        const imageData = imagePart.inlineData.data;
                        debugLog(`[å›¾ç‰‡æ•°æ®] Base64é•¿åº¦: ${imageData.length}`, 'info');
                        
                        const byteCharacters = atob(imageData);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'image/png' });
                        const blobUrl = URL.createObjectURL(blob);
                        
                        let filename = '';
                        let resolution = '';
                        
                        try {
                            debugLog(`[ä¿å­˜å›¾ç‰‡] å¼€å§‹ä¿å­˜åˆ°æœåŠ¡å™¨`, 'info');
                            const saveResponse = await fetch('/save-image', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ 
                                    imageData: imageData,
                                    prompt: prompt,
                                    aspectRatio: aspectRatio.value,
                                    imageSize: imageSize.value
                                })
                            });
                            const saveResult = await saveResponse.json();
                            debugLog(`[ä¿å­˜å›¾ç‰‡] æœåŠ¡å™¨å“åº”: ${JSON.stringify(saveResult)}`, 'info');
                            if (saveResult.success) {
                                filename = saveResult.fileName || '';
                                debugLog(`[ä¿å­˜å›¾ç‰‡] æ–‡ä»¶å: ${filename}`, 'success');
                                if (statusTag) {
                                    statusTag.innerText = "æˆåŠŸ";
                                }
                            } else {
                                debugLog(`[ä¿å­˜å›¾ç‰‡] ä¿å­˜å¤±è´¥: ${saveResult.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                                if (statusTag) {
                                    statusTag.innerText = "ä¿å­˜å¤±è´¥";
                                }
                            }
                        } catch (saveError) {
                            console.error('ä¿å­˜å›¾ç‰‡å¤±è´¥:', saveError);
                            debugLog(`[ä¿å­˜å›¾ç‰‡] å¼‚å¸¸: ${saveError.message}`, 'error');
                            if (statusTag) {
                                statusTag.innerText = "ä¿å­˜å¤±è´¥";
                            }
                        }
                        
                        const tempImg = new Image();
                        tempImg.src = blobUrl;
                        await new Promise((resolve) => {
                            tempImg.onload = () => {
                                resolution = `${tempImg.naturalWidth}x${tempImg.naturalHeight}`;
                                resolve();
                            };
                        });
                        
                        if (loadingPlaceholder) {
                            // æ›´æ–°ç°æœ‰çš„loadingå ä½ç¬¦èŠ‚ç‚¹
                            updateLoadingPlaceholder(loadingPlaceholder, blobUrl, prompt, filename, resolution);
                        } else {
                            // å¦‚æœæ²¡æœ‰å ä½ç¬¦ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹
                            const node = createImageNode(blobUrl, prompt, nodeCounter++, filename, resolution);
                        imageResponseContainer.appendChild(node);
                        selectNode(node);
                        debugLog(`[åˆ›å»ºèŠ‚ç‚¹] å›¾ç‰‡èŠ‚ç‚¹: ${filename}, åˆ†è¾¨ç‡: ${resolution}`, 'success');
                    }
                } else {
                    debugLog(`[ç”Ÿå›¾æ¨¡å¼] æ— å›¾ç‰‡æ•°æ®`, 'warning');
                    if (statusTag) {
                        statusTag.innerText = "æ— å›¾ç‰‡æ•°æ®";
                    }
                }
            } else {
                debugLog(`[æ–‡æœ¬æ¨¡å¼] å¼€å§‹å¤„ç†æ–‡æœ¬å“åº”`, 'info');
                const text = response.text();
                debugLog(`[æ–‡æœ¬å“åº”] æ–‡æœ¬é•¿åº¦: ${text.length}`, 'info');
                if (loadingPlaceholder) {
                    updateTextLoadingPlaceholder(loadingPlaceholder, text, prompt);
                    debugLog(`[æ›´æ–°èŠ‚ç‚¹] æ–‡æœ¬å ä½ç¬¦å·²æ›´æ–°`, 'success');
                } else {
                    const node = createTextNode(text, prompt, nodeCounter++);
                    imageResponseContainer.appendChild(node);
                    selectNode(node);
                    updateMinimapWithImage(node);
                    debugLog(`[åˆ›å»ºèŠ‚ç‚¹] æ–‡æœ¬èŠ‚ç‚¹å·²åˆ›å»º`, 'success');
                }
            }
                
                debugLog(`[APIå“åº”] æ¨¡å¼: ${isImageGenMode ? 'ç”Ÿå›¾' : 'æ–‡æœ¬'}, çŠ¶æ€: æˆåŠŸ`, 'success');
                
                if (activeRequests === 0 && statusTag) {
                    statusTag.innerText = "æˆåŠŸ";
                    statusTag.className = "text-xs px-2 py-1 rounded bg-green-50 text-green-600";
                }
            } catch (error) {
                console.error(error);
                debugLog(`[APIé”™è¯¯] æ¨¡å¼: ${isImageGenMode ? 'ç”Ÿå›¾' : 'æ–‡æœ¬'}, é”™è¯¯: ${error.message}`, 'error');
                const errorText = "å‘ç”Ÿé”™è¯¯: " + error.message;
                if (loadingPlaceholder) {
                    if (loadingPlaceholder.classList.contains('text-loading-placeholder')) {
                        updateTextLoadingPlaceholder(loadingPlaceholder, errorText, prompt);
                        loadingPlaceholder.querySelector('.text-prompt').style.background = '#fef2f2';
                        loadingPlaceholder.querySelector('.text-prompt').style.color = '#dc2626';
                    } else {
                        const node = createTextNode(errorText, prompt, nodeCounter++);
                        node.querySelector('.text-prompt').style.background = '#fef2f2';
                        node.querySelector('.text-prompt').style.color = '#dc2626';
                        imageResponseContainer.appendChild(node);
                        selectNode(node);
                        updateMinimapWithImage(node);
                        loadingPlaceholder.remove();
                    }
                } else {
                    const node = createTextNode(errorText, prompt, nodeCounter++);
                    node.querySelector('.text-prompt').style.background = '#fef2f2';
                    node.querySelector('.text-prompt').style.color = '#dc2626';
                    imageResponseContainer.appendChild(node);
                    selectNode(node);
                    updateMinimapWithImage(node);
                }
                if (activeRequests === 0 && statusTag) {
                    statusTag.innerText = "å¤±è´¥";
                    statusTag.className = "text-xs px-2 py-1 rounded bg-red-50 text-red-600";
                }
            } finally {
                activeRequests--;
                if (activeRequests === 0) {
                    loader.classList.add('hidden');
                }
                // æ¸…ç©ºè¾“å…¥æ¡†
                promptInput.innerHTML = '';
            }
        }

        sendBtn.addEventListener('click', callAPI);

        promptInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') callAPI();
        });

        document.addEventListener('wheel', (e) => {
            if (!e.ctrlKey) return;
            
            if (document.activeElement === promptInput) return;
            
            e.preventDefault();
            
            const currentScale = panzoom.getScale();
            const delta = e.deltaY > 0 ? -0.25 : 0.25;
            const newScale = Math.max(0.5, Math.min(2.5, currentScale + delta));
            updateCanvasScale(newScale);
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
            // Ctrl + ` åˆ‡æ¢è°ƒè¯•æ§åˆ¶é¢æ¿
            if (e.ctrlKey && e.key === '`') {
                e.preventDefault();
                debugConsole.classList.toggle('collapsed');
                return;
            }
            
            if (document.activeElement === promptInput) return;
            
            // ç”»å¸ƒç¼©æ”¾å¿«æ·é”®ï¼ˆCtrl +/-ï¼‰
            if (e.ctrlKey && !e.shiftKey && (e.key === '=' || e.key === '+')) {
                e.preventDefault();
                const currentScale = panzoom.getScale();
                const newScale = Math.min(2.5, currentScale + 0.25);
                updateCanvasScale(newScale);
                return;
            }
            
            if (e.ctrlKey && !e.shiftKey && (e.key === '-' || e.key === '_')) {
                e.preventDefault();
                const currentScale = panzoom.getScale();
                const newScale = Math.max(0.5, currentScale - 0.25);
                updateCanvasScale(newScale);
                return;
            }
            
            if (selectedNode) {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'c' || e.key === 'C') {
                        e.preventDefault();
                        copySelectedNode();
                        return;
                    }
                    if (e.key === 'x' || e.key === 'X') {
                        e.preventDefault();
                        cutSelectedNode();
                        return;
                    }
                }
                
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    deleteSelectedNode();
                    return;
                }
                
                // å¤„ç†æ–¹å‘é”®ç§»åŠ¨
                const step = 10;
                const currentLeft = parseInt(selectedNode.style.left) || 0;
                const currentTop = parseInt(selectedNode.style.top) || 0;
                
                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        selectedNode.style.top = `${currentTop - step}px`;
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        selectedNode.style.top = `${currentTop + step}px`;
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        selectedNode.style.left = `${currentLeft - step}px`;
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        selectedNode.style.left = `${currentLeft + step}px`;
                        break;
                }
            }
        });

        window.addEventListener('load', () => {
            setTimeout(initCanvas, 100);
        });
        
        // åŠ¨æ€ç›‘å¬resizeäº‹ä»¶ï¼Œå½“çª—å£å¤§å°æ”¹å˜æ—¶è‡ªåŠ¨åˆ·æ–°UI
        window.addEventListener('resize', () => {
            refreshUI();
        });
    </script>
</body>
</html>