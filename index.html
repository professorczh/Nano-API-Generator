<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå Nano Generator</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23FFD700' d='M12 2C8.5 2 5.5 4.5 4.5 8c-.5 2 .5 4 2 5.5 0 1.5-1 2.5-1.5 4 0 2.5 2 4.5 4.5 4.5 1.5 0 2.5-.5 3.5-1.5.5 1.5.5 3.5 1.5 5.5 0 2-1 3.5-2.5 4-1.5.5-3.5 0-5-1.5-2-3.5-2-5 0-2 1-3.5 2.5-4.5-.5-1.5-.5-3.5-.5-5.5 0-1.5.5-2.5 1.5-3.5-.5-1-1.5-1.5-3-1.5-2 0-3.5 1-4.5 3z'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="panzoom.min.js"></script>
    <style>
        .glass-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(230, 230, 230, 1);
        }
        .image-card {
            position: relative;
            height: 120px;
            overflow: hidden;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .image-card img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            cursor: pointer;
        }
        .image-card .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 16px;
            line-height: 1;
            z-index: 10;
        }
        .image-card:hover .delete-btn {
            opacity: 1;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #2563eb;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #2563eb;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .image-response-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .canvas-node {
            position: absolute;
            cursor: grab;
            transition: box-shadow 0.2s;
        }
        .canvas-node:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .canvas-node.selected {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            outline: 2px solid #3b82f6;
        }
        .canvas-node img {
            display: block;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            max-width: 300px;
            max-height: 300px;
        }
        .canvas-node .node-info {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .canvas-node:hover .node-info {
            opacity: 1;
        }
        .canvas-node .node-header {
            position: absolute;
            top: -35px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }
        .canvas-node.selected .node-header {
            display: flex;
        }
        .canvas-node .node-filename {
            background: rgba(255, 255, 255, 0.95);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .canvas-node .node-resolution {
            background: rgba(255, 255, 255, 0.95);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .canvas-node .resize-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .canvas-node.selected .resize-handle {
            opacity: 1;
        }
        .pin-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }
        .pin-marker:hover {
            transform: scale(1.2);
        }
        .pin-marker .pin-delete {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 14px;
            height: 14px;
            background: #1f2937;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .pin-marker:hover .pin-delete {
            opacity: 1;
        }
        .pinned-image-tag {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            height: 32px;
            vertical-align: middle;
            margin: 0 2px;
            position: relative;
        }
        .pinned-image-tag:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        .pinned-image-tag .pin-number {
            width: 18px;
            height: 18px;
            background: #f59e0b;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        .pinned-image-tag .tag-delete {
            display: none;
            width: 16px;
            height: 16px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            margin-left: 4px;
        }
        .pinned-image-tag:hover .tag-delete {
            display: block;
        }
        .pinned-image-tag .image-preview-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
            pointer-events: none;
            max-width: 800px;
            max-height: 800px;
            overflow: visible;
        }
        .pinned-image-tag:hover .image-preview-tooltip {
            display: block;
        }
        .pinned-image-tag .image-preview-tooltip img {
            width: auto;
            height: auto;
            min-width: 100px;
            min-height: 100px;
            max-width: 800px;
            max-height: 800px;
            display: block;
            border-radius: 4px;
            object-fit: contain;
            position: relative;
        }
        .pinned-image-tag .image-preview-tooltip .pin-indicator {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: pinZoom 0.3s ease-out;
            transform: translate(-50%, -50%);
        }
        @keyframes pinZoom {
            0% {
                transform: scale(3);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .pasted-image-item {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            height: 32px;
            vertical-align: middle;
            margin: 0 2px;
        }
        #promptInput:empty:before {
            content: attr(data-placeholder);
            color: #9ca3af;
            pointer-events: none;
        }
        #promptInput:focus {
            outline: none;
        }
        .pasted-image-item:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        .pasted-image-item img {
            width: 24px;
            height: 24px;
            object-fit: cover;
            border-radius: 4px;
        }
        .pasted-image-item .delete-btn {
            display: none;
            width: 16px;
            height: 16px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            margin-left: 4px;
        }
        .pasted-image-item:hover .delete-btn {
            display: block;
        }
        .pasted-image-item .image-preview-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
            pointer-events: none;
            max-width: 800px;
            max-height: 800px;
        }
        .pasted-image-item:hover .image-preview-tooltip {
            display: block;
        }
        .pasted-image-item .image-preview-tooltip img {
            width: auto;
            height: auto;
            min-width: 100px;
            min-height: 100px;
            max-width: 800px;
            max-height: 800px;
            display: block;
            border-radius: 4px;
            object-fit: contain;
        }
        #canvasViewport {
            cursor: default;
        }
        #canvas {
            background-color: #f9fafb;
            background-image: radial-gradient(circle, #d1d5db 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: default;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            padding: 8px 0;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: background-color 0.15s ease;
        }

        .context-menu-item:hover {
            background-color: #f3f4f6;
        }

        .context-menu-item:active {
            background-color: #e5e7eb;
        }

        .loading-placeholder {
            position: absolute;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .loading-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.3), transparent);
            animation: slide 1.5s infinite;
        }

        @keyframes slide {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        .loading-placeholder .loading-text {
            position: relative;
            z-index: 1;
            color: #6b7280;
            font-size: 14px;
            font-weight: 500;
        }

        .debug-console {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1e293b;
            border-top: 2px solid #3b82f6;
            z-index: 10001;
            transition: transform 0.3s ease;
        }

        .debug-console.collapsed {
            transform: translateY(calc(100% - 24px));
        }

        .debug-console-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: #0f172a;
            cursor: pointer;
            user-select: none;
            height: 24px;
            min-height: 24px;
        }

        .debug-console-title {
            color: #e2e8f0;
            font-size: 14px;
            font-weight: 600;
        }

        .debug-console-toggle {
            color: #94a3b8;
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .debug-console.collapsed .debug-console-toggle {
            transform: rotate(180deg);
        }

        .debug-console-content {
            max-height: 300px;
            overflow-y: auto;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .debug-log {
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            word-wrap: break-word;
        }

        .debug-log.info {
            background: #1e40af;
            color: #dbeafe;
        }

        .debug-log.success {
            background: #065f46;
            color: #d1fae5;
        }

        .debug-log.warning {
            background: #92400e;
            color: #fef3c7;
        }

        .debug-log.error {
            background: #991b1b;
            color: #fecaca;
        }

        .debug-log.event {
            background: #374151;
            color: #e5e7eb;
        }

        .debug-log .timestamp {
            color: #9ca3af;
            margin-right: 8px;
        }

        .debug-log .message {
            color: inherit;
        }

        .debug-console-clear {
            position: absolute;
            top: 8px;
            right: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 1;
        }

        .debug-console-clear:hover {
            background: #2563eb;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen text-gray-800">

    <div class="w-full mx-auto py-12 px-4">
        <header class="mb-10 text-center">
            <h1 class="text-3xl font-bold text-gray-900">Nano Generator</h1>
        </header>

        <main class="flex gap-6 w-full">
            <div class="glass-card rounded-2xl p-6 shadow-sm min-h-[200px] w-[70%] flex flex-col">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">ËøîÂõûÁªìÊûú (Response)</h2>
                    <div class="flex items-center gap-2">
                        <span id="statusTag" class="text-xs px-2 py-1 rounded bg-gray-100 text-gray-500">Á≠âÂæÖ‰∏≠</span>
                        <button id="resetCanvasBtn" class="text-xs px-2 py-1 rounded bg-blue-100 text-blue-600 hover:bg-blue-200">ÈáçÁΩÆÁîªÂ∏É</button>
                    </div>
                </div>
                <div id="canvasViewport" class="flex-1 relative overflow-hidden bg-gray-50 border border-gray-200 rounded-lg min-h-[400px]">
                    <div id="canvas" class="absolute origin-center transition-transform duration-75 ease-out" style="width: 2000px; height: 2000px; left: -750px; top: -750px;">
                        <div id="responseOutput" class="whitespace-pre-wrap text-gray-700 leading-relaxed italic text-gray-400 p-4">
                            ÂÜÖÂÆπÂ∞ÜÂú®Ê≠§Â§ÑÊòæÁ§∫...
                        </div>
                        <div id="imageResponseContainer">
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex-1 space-y-6 w-[30%]">
                <div class="glass-card rounded-2xl p-6 shadow-sm">
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center gap-2">
                            <label class="block text-sm font-medium text-gray-700">API Key</label>
                            <a href="https://aistudio.google.com/api-keys" target="_blank" class="text-xs text-blue-600 hover:text-blue-700 underline">Ëé∑Âèñ API Key</a>
                        </div>
                        <button id="toggleApiKeyPanel" class="text-sm text-blue-600 hover:text-blue-700">ÊäòÂè†</button>
                    </div>
                    <div id="apiKeyPanel">
                        <div class="flex gap-3">
                            <input type="text" id="apiKeyInput" 
                                class="flex-1 p-4 rounded-xl border border-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all"
                                placeholder="ËæìÂÖ•‰Ω†ÁöÑ API Key">
                            <button id="testApiKeyBtn" 
                                class="bg-gray-600 hover:bg-gray-700 text-white px-5 py-2.5 rounded-lg font-medium transition-colors shadow-sm flex items-center gap-2 whitespace-nowrap">
                                <span>ÊµãËØï</span>
                                <div id="testLoader" class="hidden animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full"></div>
                            </button>
                        </div>
                        <div id="apiStatus" class="mt-2 text-sm text-gray-500"></div>
                        
                        <div class="mt-3 flex gap-3">
                            <button id="saveApiKeyBtn" 
                                class="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-medium transition-colors shadow-sm text-sm">
                                Â≠òÂÇ® API
                            </button>
                            <button id="clearApiKeyBtn" 
                                class="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-medium transition-colors shadow-sm text-sm">
                                Ê∏ÖÈô§ API
                            </button>
                        </div>
                        
                        <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">
                            <div>
                                <label class="block text-xs font-medium text-gray-500 mb-1">ÊñáÊú¨Ê®°Âûã</label>
                                <select id="textModelName" 
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-500 mb-1">ËØÜÂõæÊ®°Âûã</label>
                                <select id="visionModelName" 
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-500 mb-1">ÁîüÂõæÊ®°Âûã</label>
                                <select id="imageModelName" 
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="glass-card rounded-2xl p-6 shadow-sm">
                    <div class="flex items-center justify-between mb-2">
                        <label class="block text-sm font-medium text-gray-700">ÊèêÁ§∫ËØç</label>
                        <button id="togglePromptPanel" class="text-sm text-blue-600 hover:text-blue-700">ÊäòÂè†</button>
                    </div>
                    <div id="promptPanel">
                        <div id="promptContainer" class="w-full p-4 rounded-xl border border-gray-200 focus-within:ring-2 focus-within:ring-blue-500 focus-within:border-transparent outline-none transition-all bg-white min-h-[120px]">
                            <div id="promptInput" contenteditable="true" 
                                class="w-full border-none outline-none resize-none bg-transparent text-gray-700 placeholder-gray-400 whitespace-pre-wrap"
                                data-placeholder="ËØ∑ËæìÂÖ•ÊèêÁ§∫ËØç"></div>
                        </div>
                        
                        <div class="mt-4 flex justify-between items-center">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="imageGenMode" class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                <span class="text-gray-700 font-medium">ÁîüÂõæÊ®°Âºè</span>
                            </label>
                            <button id="sendBtn" 
                                class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2.5 rounded-lg font-medium transition-colors shadow-sm flex items-center gap-2">
                                <span>ÂèëÈÄÅ</span>
                                <div id="loader" class="hidden animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full"></div>
                            </button>
                        </div>

                        <div id="imageGenOptions" class="mt-4">
                            <div class="border-t border-gray-200 pt-4">
                                <h3 class="text-sm font-semibold text-gray-700 mb-3">ÁîüÂõæÂèÇÊï∞ËÆæÁΩÆ</h3>
                                
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">ÂÆΩÈ´òÊØî</label>
                                        <select id="aspectRatio" 
                                            class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                            <option value="1:1">1:1 Ê≠£ÊñπÂΩ¢</option>
                                            <option value="16:9" selected>16:9 ÂÆΩÂ±è</option>
                                            <option value="9:16">9:16 Á´ñÂ±è</option>
                                            <option value="21:9">21:9 Ë∂ÖÂÆΩÂ±è</option>
                                            <option value="4:3">4:3 ‰º†ÁªüÊ®™Âêë</option>
                                            <option value="3:4">3:4 ‰º†ÁªüÁ´ñÂêë</option>
                                            <option value="3:2">3:2 ÁªèÂÖ∏Ê®™Âêë</option>
                                            <option value="2:3">2:3 ÁªèÂÖ∏Á´ñÂêë</option>
                                            <option value="5:4">5:4 Â§ßÁîªÂπÖÊ®™Âêë</option>
                                            <option value="4:5">4:5 Â§ßÁîªÂπÖÁ´ñÂêë</option>
                                        </select>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">ÂàÜËæ®Áéá</label>
                                        <select id="imageSize" 
                                            class="w-full px-3 py-2 rounded-lg border border-gray-200 bg-white text-gray-700 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all">
                                            <option value="1K" selected>1K (1024px)</option>
                                            <option value="2K">2K È´òÊ∏Ö</option>
                                            <option value="4K">4K Ë∂ÖÈ´òÊ∏Ö</option>
                                        </select>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                            Ê∏©Â∫¶: <span id="temperatureValue">0.6</span>
                                        </label>
                                        <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.6" 
                                            class="w-full">
                                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                                            <span>Á°ÆÂÆöÊÄß</span>
                                            <span>ÂàõÈÄ†ÊÄß</span>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                            Top-P: <span id="topPValue">0.95</span>
                                        </label>
                                        <input type="range" id="topP" min="0" max="1" step="0.05" value="0.95" 
                                            class="w-full">
                                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                                            <span>ÈõÜ‰∏≠</span>
                                            <span>Â§öÊ†∑</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="debugConsole" class="debug-console">
        <div class="debug-console-header">
            <span class="debug-console-title">Ë∞ÉËØïÊéßÂà∂Âè∞</span>
            <span class="debug-console-toggle">‚ñº</span>
        </div>
        <div class="debug-console-content" id="debugConsoleContent">
            <button class="debug-console-clear" id="debugConsoleClear">Ê∏ÖÁ©∫</button>
        </div>
    </div>

    <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-90 hidden items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl p-6 max-w-[95vw] max-h-[95vh] w-full shadow-2xl flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-lg font-semibold text-gray-900">ÂõæÁâáÈ¢ÑËßà</h3>
                <button id="closeModalBtn" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
            </div>
            <div class="flex justify-center mb-6 flex-grow overflow-auto">
                <img id="modalImage" class="max-w-full max-h-[75vh] rounded-lg object-contain" alt="È¢ÑËßàÂõæÁâá">
            </div>
            <div class="flex justify-end gap-3 flex-shrink-0">
                <button id="openFolderBtn" class="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">ÊâìÂºÄÊñá‰ª∂Â§π</button>
                <button id="closeModalBtn2" class="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">ÂÖ≥Èó≠</button>
                <button id="downloadModalBtn" class="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors">‰∏ãËΩΩ</button>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai"
      }
    }
    </script>
    
    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";
        import { CONFIG, TEXT_MODELS, IMAGE_MODELS } from "./config.js";

        const sendBtn = document.getElementById('sendBtn');
        const promptInput = document.getElementById('promptInput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const responseOutput = document.getElementById('responseOutput');
        const loader = document.getElementById('loader');
        const statusTag = document.getElementById('statusTag');
        const testApiKeyBtn = document.getElementById('testApiKeyBtn');
        const testLoader = document.getElementById('testLoader');
        const apiStatus = document.getElementById('apiStatus');
        const imageGenMode = document.getElementById('imageGenMode');
        const imageGenOptions = document.getElementById('imageGenOptions');
        const aspectRatio = document.getElementById('aspectRatio');
        const imageSize = document.getElementById('imageSize');
        const temperature = document.getElementById('temperature');
        const topP = document.getElementById('topP');
        const temperatureValue = document.getElementById('temperatureValue');
        const topPValue = document.getElementById('topPValue');
        const imageResponseContainer = document.getElementById('imageResponseContainer');
        const textModelName = document.getElementById('textModelName');
        const visionModelName = document.getElementById('visionModelName');
        const imageModelName = document.getElementById('imageModelName');
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const closeModalBtn2 = document.getElementById('closeModalBtn2');
        const downloadModalBtn = document.getElementById('downloadModalBtn');
        const openFolderBtn = document.getElementById('openFolderBtn');
        const toggleApiKeyPanel = document.getElementById('toggleApiKeyPanel');
        const togglePromptPanel = document.getElementById('togglePromptPanel');
        const apiKeyPanel = document.getElementById('apiKeyPanel');
        const promptPanel = document.getElementById('promptPanel');
        const canvasViewport = document.getElementById('canvasViewport');
        const canvas = document.getElementById('canvas');
        const resetCanvasBtn = document.getElementById('resetCanvasBtn');
        const debugConsole = document.getElementById('debugConsole');
        const debugConsoleContent = document.getElementById('debugConsoleContent');
        const debugConsoleClear = document.getElementById('debugConsoleClear');
        let currentBlobUrl = null;
        let panzoom = null;
        let selectedNode = null;
        let nodeCounter = 0;
        let pinCounter = 0;
        let imagePins = new Map();
        let isMiddleMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let panX = -750;
        let panY = -750;
        let isDraggingNode = false;
        let dragNode = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragNodeStartLeft = 0;
        let dragNodeStartTop = 0;
        let isResizingNode = false;
        let resizeStart = { x: 0, y: 0, width: 0, height: 0 };
        let resizeNode = null;

        function debugLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `debug-log ${type}`;
            
            const timestamp = document.createElement('span');
            timestamp.className = 'timestamp';
            const now = new Date();
            timestamp.textContent = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.className = 'message';
            messageSpan.textContent = message;
            
            logEntry.appendChild(timestamp);
            logEntry.appendChild(messageSpan);
            debugConsoleContent.insertBefore(logEntry, debugConsoleContent.firstChild.nextSibling);
            
            const maxLogs = 100;
            const logs = debugConsoleContent.querySelectorAll('.debug-log');
            if (logs.length > maxLogs) {
                for (let i = maxLogs; i < logs.length; i++) {
                    logs[i].remove();
                }
            }
        }

        debugConsole.addEventListener('click', () => {
            debugConsole.classList.toggle('collapsed');
        });

        debugConsoleClear.addEventListener('click', (e) => {
            e.stopPropagation();
            const logs = debugConsoleContent.querySelectorAll('.debug-log');
            logs.forEach(log => log.remove());
        });

        function maskApiKey(apiKey) {
            if (!apiKey || apiKey.length < 6) return apiKey;
            return apiKey.substring(0, 3) + '*'.repeat(apiKey.length - 6) + apiKey.substring(apiKey.length - 3);
        }

        function updateApiKeyDisplay() {
            const apiKey = apiKeyInput.value;
            if (apiKey) {
                apiKeyInput.value = maskApiKey(apiKey);
            }
        }

        apiKeyInput.value = CONFIG.API_KEY;
        updateApiKeyDisplay();

        apiKeyInput.addEventListener('focus', () => {
            apiKeyInput.value = CONFIG.API_KEY;
        });

        apiKeyInput.addEventListener('blur', () => {
            const newValue = apiKeyInput.value.trim();
            if (newValue && newValue !== maskApiKey(CONFIG.API_KEY)) {
                CONFIG.API_KEY = newValue;
            }
            updateApiKeyDisplay();
        });

        apiKeyInput.addEventListener('input', () => {
            const newValue = apiKeyInput.value.trim();
            if (newValue && !newValue.includes('*')) {
                CONFIG.API_KEY = newValue;
            }
        });

        toggleApiKeyPanel.addEventListener('click', () => {
            if (apiKeyPanel.classList.contains('hidden')) {
                apiKeyPanel.classList.remove('hidden');
                toggleApiKeyPanel.textContent = 'ÊäòÂè†';
            } else {
                apiKeyPanel.classList.add('hidden');
                toggleApiKeyPanel.textContent = 'Â±ïÂºÄ';
            }
        });

        togglePromptPanel.addEventListener('click', () => {
            if (promptPanel.classList.contains('hidden')) {
                promptPanel.classList.remove('hidden');
                togglePromptPanel.textContent = 'ÊäòÂè†';
            } else {
                promptPanel.classList.add('hidden');
                togglePromptPanel.textContent = 'Â±ïÂºÄ';
            }
        });

        function initCanvas() {
            console.log('Initializing canvas...');
            console.log('Canvas element:', canvas);
            console.log('CanvasViewport:', canvasViewport);
            
            if (typeof Panzoom === 'undefined') {
                console.error('Panzoom library not loaded');
                return;
            }
            
            panzoom = Panzoom(canvas, {
                maxScale: 3,
                minScale: 0.3,
                step: 0.1,
                disablePan: true,
                disableZoom: false
            });
            
            isMiddleMouseDown = false;
            lastMouseX = 0;
            lastMouseY = 0;
            panX = -750;
            panY = -750;
            
            const scale = panzoom.getScale();
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            
            canvasViewport.style.cursor = 'default';
            canvas.style.cursor = 'default';
            
            canvasViewport.addEventListener('mousedown', (e) => {
                debugLog(`[Èº†Ê†áÊåâ‰∏ã] ÁîªÂ∏ÉËßÜÂè£: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}`, 'event');
                if (e.button === 1) {
                    e.preventDefault();
                    isMiddleMouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvasViewport.style.cursor = 'grabbing';
                    debugLog(`[ÂºÄÂßãÊãñÂä®] ÁîªÂ∏É: isMiddleMouseDown=${isMiddleMouseDown}`, 'info');
                } else {
                    canvasViewport.style.cursor = 'default';
                }
            });
            
            canvasViewport.addEventListener('mouseenter', () => {
                canvasViewport.style.cursor = 'default';
                canvas.style.cursor = 'default';
            });
            
            canvasViewport.addEventListener('mouseleave', () => {
                canvasViewport.style.cursor = '';
                canvas.style.cursor = '';
            });
            
            canvasViewport.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            resetCanvasBtn.addEventListener('click', resetCanvas);
            console.log('Canvas initialized successfully');
        }

        function resetCanvas() {
            if (panzoom) {
                panzoom.reset();
                panX = -750;
                panY = -750;
                const scale = panzoom.getScale();
                canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            }
        }

        document.addEventListener('mousemove', (e) => {
            if (isDraggingNode && dragNode) {
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;
                
                const newLeft = dragNodeStartLeft + deltaX;
                const newTop = dragNodeStartTop + deltaY;
                
                dragNode.style.left = `${newLeft}px`;
                dragNode.style.top = `${newTop}px`;
                
                debugLog(`ÊãñÂä®ÂõæÁâá: delta=(${deltaX},${deltaY}), newPos=(${newLeft},${newTop})`, 'event');
            }
            
            if (isMiddleMouseDown && !isDraggingNode) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                panX += deltaX;
                panY += deltaY;
                
                const scale = panzoom.getScale();
                canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                    debugLog(`ÁîªÂ∏ÉÊãñÂä®: deltaX=${deltaX}, deltaY=${deltaY}, panX=${panX}, panY=${panY}`, 'event');
                }
            }
            
            if (isResizingNode && resizeNode) {
                const deltaX = e.clientX - resizeStart.x;
                const deltaY = e.clientY - resizeStart.y;
                const delta = Math.max(deltaX, deltaY);
                
                const aspectRatio = resizeStart.width / resizeStart.height;
                let newWidth = resizeStart.width + delta;
                let newHeight = resizeStart.height + delta;
                
                if (newWidth > 50 && newHeight > 50) {
                    const img = resizeNode.querySelector('img');
                    img.style.width = `${newWidth}px`;
                    img.style.height = `${newHeight}px`;
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            debugLog(`[Èº†Ê†áÊä¨Ëµ∑] ÂÖ®Â±Ä: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}`, 'event');
            
            if (isDraggingNode && dragNode) {
                debugLog(`[ÁªìÊùüÊãñÂä®] ÂõæÁâá: node=${dragNode.dataset.filename}`, 'info');
                dragNode.style.cursor = 'grab';
                isDraggingNode = false;
                dragNode = null;
            }
            
            if (isResizingNode && resizeNode) {
                debugLog(`[ÁªìÊùüË∞ÉÊï¥Â§ßÂ∞è] ËäÇÁÇπ: node=${resizeNode.dataset.filename}`, 'info');
                isResizingNode = false;
                resizeNode = null;
                document.body.style.cursor = '';
            }
            
            if (isMiddleMouseDown) {
                debugLog(`[Èº†Ê†á‰∏≠ÈîÆÈáäÊîæ] ÂÖ®Â±Ä: isMiddleMouseDown=${isMiddleMouseDown}`, 'info');
                isMiddleMouseDown = false;
                canvasViewport.style.cursor = 'default';
            }
        });

        function createImageNode(imageUrl, prompt = '', index = 0, filename = '', resolution = '') {
            console.log('Creating image node...');
            console.log('Image URL:', imageUrl);
            console.log('Prompt:', prompt);
            console.log('Index:', index);
            console.log('Filename:', filename);
            console.log('Resolution:', resolution);
            
            const node = document.createElement('div');
            node.className = 'canvas-node';
            node.dataset.index = index;
            node.dataset.imageUrl = imageUrl;
            node.dataset.filename = filename || `Image ${index + 1}`;
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = `Generated image ${index + 1}`;
            img.draggable = false;
            
            img.onload = function() {
                const width = this.naturalWidth;
                const height = this.naturalHeight;
                const resolutionText = `${width}x${height}`;
                const resolutionElement = node.querySelector('.node-resolution');
                if (resolutionElement) {
                    resolutionElement.textContent = resolutionText;
                }
                node.dataset.width = width;
                node.dataset.height = height;
            };
            
            const header = document.createElement('div');
            header.className = 'node-header';
            
            const filenameElement = document.createElement('div');
            filenameElement.className = 'node-filename';
            filenameElement.textContent = filename || `Image ${index + 1}`;
            
            const resolutionElement = document.createElement('div');
            resolutionElement.className = 'node-resolution';
            resolutionElement.textContent = resolution || 'Loading...';
            
            header.appendChild(filenameElement);
            header.appendChild(resolutionElement);
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            
            const info = document.createElement('div');
            info.className = 'node-info';
            info.textContent = prompt || `Image ${index + 1}`;
            
            node.appendChild(header);
            node.appendChild(img);
            node.appendChild(resizeHandle);
            node.appendChild(info);
            
            node.dataset.pins = JSON.stringify([]);
            
            if (!node.style.left) {
                const x = 800 + (index * 320) % 400;
                const y = 800 + Math.floor((index * 320) / 400) * 320;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
            }
            
            console.log('Node position:', node.style.left, node.style.top);
            
            img.addEventListener('click', (e) => {
                e.stopPropagation();
                debugLog(`ÂõæÁâáÁÇπÂáª: button=${e.button}, ctrlKey=${e.ctrlKey}, metaKey=${e.metaKey}, selected=${node.classList.contains('selected')}`, 'event');
                if (e.ctrlKey || e.metaKey) {
                    if (node.classList.contains('selected')) {
                        debugLog(`Ê∑ªÂä† PIN: ÂõæÁâáÂ∑≤ÈÄâ‰∏≠`, 'info');
                        addPinToImage(node, e);
                    } else {
                        debugLog(`ÈÄâ‰∏≠ÂõæÁâá: Êú™ÈÄâ‰∏≠ÔºåÊåâ‰Ωè Ctrl/Meta`, 'info');
                        selectNode(node);
                    }
                } else {
                    debugLog(`ÈÄâ‰∏≠ÂõæÁâá: Â∑¶ÈîÆÁÇπÂáª`, 'info');
                    selectNode(node);
                }
            });
            
            node.addEventListener('mousedown', (e) => {
                debugLog(`[Èº†Ê†áÊåâ‰∏ã] ËäÇÁÇπ: button=${e.button}, clientX=${e.clientX}, clientY=${e.clientY}, selected=${node.classList.contains('selected')}, ctrlKey=${e.ctrlKey}, metaKey=${e.metaKey}`, 'event');
                if (e.button === 0 && !e.ctrlKey && !e.metaKey) {
                    selectNode(node);
                    
                    // ËÆæÁΩÆÂÖ®Â±ÄÊãñÂä®Áä∂ÊÄÅ
                    isDraggingNode = true;
                    dragNode = node;
                    
                    // ËÆ∞ÂΩïÂàùÂßã‰ΩçÁΩÆ
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    dragNodeStartLeft = parseInt(node.style.left || '0');
                    dragNodeStartTop = parseInt(node.style.top || '0');
                    
                    debugLog(`[ÂºÄÂßãÊãñÂä®] ÂõæÁâá: node=${node.dataset.filename}`, 'info');
                }
            });
            
            node.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showImageContextMenu(e, node, img);
            });
            
            img.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showImageContextMenu(e, node, img);
            });
            
            resizeHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                startResizeNode(e, node);
            });
            
            console.log('Node created:', node);
            return node;
        }

        function selectNode(node) {
            if (selectedNode) {
                selectedNode.classList.remove('selected');
            }
            selectedNode = node;
            node.classList.add('selected');
        }



        function startResizeNode(e, node) {
            isResizingNode = true;
            resizeNode = node;
            const img = node.querySelector('img');
            const rect = img.getBoundingClientRect();
            resizeStart = {
                x: e.clientX,
                y: e.clientY,
                width: rect.width,
                height: rect.height
            };
            document.body.style.cursor = 'nwse-resize';
        }

        canvas.addEventListener('click', (e) => {
            debugLog(`ÁîªÂ∏ÉÁÇπÂáª: button=${e.button}, target=${e.target.id || e.target.className}`, 'event');
            if (e.target === canvas || e.target === imageResponseContainer) {
                debugLog(`ÂèñÊ∂àÈÄâ‰∏≠ÊâÄÊúâËäÇÁÇπ`, 'info');
                deselectAllNodes();
            }
        });

        function deselectAllNodes() {
            if (selectedNode) {
                selectedNode.classList.remove('selected');
                selectedNode = null;
            }
        }

        function addSampleImage() {
            let svgContent = '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" viewBox="0 0 500 500">';
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9', '#F8B500', '#00CED1', '#FF69B4', '#32CD32', '#FFD700', '#FF6347', '#7B68EE', '#20B2AA', '#FFA500', '#9370DB', '#DC143C', '#00FA9A', '#FF1493', '#00BFFF', '#FF4500'];
            
            let colorIndex = 0;
            for (let row = 1; row <= 5; row++) {
                for (let col = 1; col <= 5; col++) {
                    const x = (col - 1) * 100;
                    const y = (row - 1) * 100;
                    const color = colors[colorIndex % colors.length];
                    
                    svgContent += `<rect x="${x}" y="${y}" width="100" height="100" fill="${color}" stroke="#fff" stroke-width="2"/>`;
                    svgContent += `<text x="${x + 50}" y="${y + 50}" dominant-baseline="middle" text-anchor="middle" font-size="20" font-weight="bold" fill="#fff" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${row}.${col}</text>`;
                    
                    colorIndex++;
                }
            }
            
            svgContent += '</svg>';
            const sampleImageUrl = `data:image/svg+xml,${encodeURIComponent(svgContent)}`;
            
            const existingSample = imageResponseContainer.querySelector('[data-filename="sample_image.png"]');
            if (existingSample) {
                console.log('Sample image already exists, skipping...');
                return;
            }
            
            const node = createImageNode(sampleImageUrl, '5x5 ÁΩëÊ†º', nodeCounter++, 'sample_image.png', '500x500');
            imageResponseContainer.appendChild(node);
        }

        function openModal(blobUrl) {
            currentBlobUrl = blobUrl;
            modalImage.src = blobUrl;
            imageModal.classList.remove('hidden');
            imageModal.classList.add('flex');
        }

        function closeModal() {
            imageModal.classList.add('hidden');
            imageModal.classList.remove('flex');
        }

        closeModalBtn.addEventListener('click', closeModal);
        closeModalBtn2.addEventListener('click', closeModal);
        imageModal.addEventListener('click', (e) => {
            if (e.target === imageModal) {
                closeModal();
            }
        });

        downloadModalBtn.addEventListener('click', () => {
            if (currentBlobUrl) {
                const link = document.createElement('a');
                link.href = currentBlobUrl;
                link.download = `gemini-generated-${Date.now()}.png`;
                link.click();
            }
        });

        openFolderBtn.addEventListener('click', async () => {
            try {
                const response = await fetch('/open-folder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                const result = await response.json();
                if (result.success) {
                    alert(`${result.message}\n\nËØ∑Â§çÂà∂Ë∑ØÂæÑÂπ∂Âú®Êñá‰ª∂ËµÑÊ∫êÁÆ°ÁêÜÂô®‰∏≠ÊâìÂºÄ`);
                    navigator.clipboard.writeText(result.path).then(() => {
                        console.log('Ë∑ØÂæÑÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                    }).catch(err => {
                        console.error('Â§çÂà∂Â§±Ë¥•:', err);
                    });
                } else {
                    alert('ÊâìÂºÄÊñá‰ª∂Â§πÂ§±Ë¥•: ' + result.error);
                }
            } catch (error) {
                alert('ÊâìÂºÄÊñá‰ª∂Â§πÂ§±Ë¥•: ' + error.message);
            }
        });

        apiKeyInput.value = CONFIG.API_KEY;

        function populateModelSelects() {
            TEXT_MODELS.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                if (model.value === CONFIG.MODEL_NAME) {
                    option.selected = true;
                }
                textModelName.appendChild(option);
                
                const visionOption = document.createElement('option');
                visionOption.value = model.value;
                visionOption.textContent = model.name;
                if (model.value === CONFIG.MODEL_NAME) {
                    visionOption.selected = true;
                }
                visionModelName.appendChild(visionOption);
            });

            IMAGE_MODELS.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                if (model.value === CONFIG.IMAGE_MODEL_NAME) {
                    option.selected = true;
                }
                imageModelName.appendChild(option);
            });
        }

        populateModelSelects();

        let imageDataList = [];
        let pasteImageCounter = 0;

        function createImageTag(imageData, index) {
            const item = document.createElement('span');
            item.className = 'pasted-image-item';
            item.style.position = 'relative';
            item.dataset.index = index;
            item.dataset.imageUrl = imageData.data;
            item.dataset.filename = imageData.name;
            item.contentEditable = 'false';
            
            const img = document.createElement('img');
            img.src = imageData.data;
            img.alt = imageData.name;
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = imageData.name.length > 20 ? imageData.name.substring(0, 20) + '...' : imageData.name;
            nameSpan.title = imageData.name;
            
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '√ó';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                item.remove();
                updateImageDataList();
            };
            
            const tooltip = document.createElement('div');
            tooltip.className = 'image-preview-tooltip';
            
            const tooltipImg = document.createElement('img');
            tooltipImg.src = imageData.data;
            tooltipImg.alt = imageData.name;
            
            tooltip.appendChild(tooltipImg);
            
            item.appendChild(img);
            item.appendChild(nameSpan);
            item.appendChild(deleteBtn);
            item.appendChild(tooltip);
            
            return item;
        }

        promptInput.addEventListener('paste', async (e) => {
            const items = e.clipboardData.items;
            
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const base64Data = event.target.result;
                        const baseName = file.name || 'image.png';
                        const ext = baseName.includes('.') ? baseName.split('.').pop() : 'png';
                        const uniqueName = `image_${pasteImageCounter + 1}.${ext}`;
                        
                        const imageData = {
                            data: base64Data,
                            name: uniqueName
                        };
                        
                        const imageTag = createImageTag(imageData, imageDataList.length);
                        insertAtCursor(imageTag);
                        updateImageDataList();
                        
                        pasteImageCounter++;
                    };
                    
                    reader.readAsDataURL(file);
                }
            }
        });
        
        document.addEventListener('paste', (e) => {
            if (!imageGenMode.checked) return;
            
            const isInInput = document.activeElement === promptInput || promptInput.contains(document.activeElement);
            if (isInInput) return;
            
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const base64Data = event.target.result;
                        const baseName = file.name || 'image.png';
                        const ext = baseName.includes('.') ? baseName.split('.').pop() : 'png';
                        const uniqueName = `pasted_${Date.now()}.${ext}`;
                        
                        const node = createImageNode(base64Data, 'Á≤òË¥¥ÂõæÁâá', nodeCounter++, uniqueName, `${file.width || 500}x${file.height || 500}`);
                        imageResponseContainer.appendChild(node);
                    };
                    
                    reader.readAsDataURL(file);
                    break;
                }
            }
        });

        function insertAtCursor(node) {
            const selection = window.getSelection();
            
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                
                const parent = promptInput;
                if (parent.contains(range.commonAncestorContainer) || parent === range.commonAncestorContainer) {
                    range.deleteContents();
                    
                    const spaceBefore = document.createTextNode(' ');
                    const spaceAfter = document.createTextNode(' ');
                    
                    range.insertNode(spaceBefore);
                    range.insertNode(node);
                    range.insertNode(spaceAfter);
                    
                    const newRange = document.createRange();
                    newRange.setStartAfter(node);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                } else {
                    const spaceBefore = document.createTextNode(' ');
                    const spaceAfter = document.createTextNode(' ');
                    promptInput.appendChild(spaceBefore);
                    promptInput.appendChild(node);
                    promptInput.appendChild(spaceAfter);
                    
                    const newRange = document.createRange();
                    newRange.setStartAfter(node);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            } else {
                const spaceBefore = document.createTextNode(' ');
                const spaceAfter = document.createTextNode(' ');
                promptInput.appendChild(spaceBefore);
                promptInput.appendChild(node);
                promptInput.appendChild(spaceAfter);
                
                const newRange = document.createRange();
                newRange.setStartAfter(node);
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
            
            promptInput.focus();
        }

        function updateImageDataList() {
            imageDataList = [];
            const imageTags = promptInput.querySelectorAll('.pasted-image-item');
            imageTags.forEach((tag, index) => {
                imageDataList.push({
                    data: tag.dataset.imageUrl,
                    name: tag.dataset.filename
                });
                tag.dataset.index = index;
            });
        }

        function addCanvasImageToPrompt(node) {
            const imageUrl = node.dataset.imageUrl;
            const filename = node.dataset.filename;
            
            const existingTags = promptInput.querySelectorAll('.pasted-image-item');
            for (let tag of existingTags) {
                if (tag.dataset.imageUrl === imageUrl) {
                    return;
                }
            }
            
            const imageData = {
                data: imageUrl,
                name: filename
            };
            
            const imageTag = createImageTag(imageData, imageDataList.length);
            insertAtCursor(imageTag);
            updateImageDataList();
        }

        function addPinToImage(node, event) {
            const img = node.querySelector('img');
            const rect = img.getBoundingClientRect();
            
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = rect.width;
            const displayHeight = rect.height;
            
            const x = (event.clientX - rect.left) * (naturalWidth / displayWidth);
            const y = (event.clientY - rect.top) * (naturalHeight / displayHeight);
            
            const pins = JSON.parse(node.dataset.pins || '[]');
            
            pinCounter++;
            const pin = {
                id: Date.now(),
                number: pinCounter,
                x: x,
                y: y
            };
            
            pins.push(pin);
            pins.sort((a, b) => a.number - b.number);
            node.dataset.pins = JSON.stringify(pins);
            
            createPinMarker(node, pin, displayWidth, displayHeight);
            updatePromptWithPins(node);
        }

        function createPinMarker(node, pin, displayWidth, displayHeight) {
            const img = node.querySelector('img');
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            const displayX = pin.x * scaleX;
            const displayY = pin.y * scaleY;
            
            const marker = document.createElement('div');
            marker.className = 'pin-marker';
            marker.dataset.pinId = pin.id;
            marker.textContent = pin.number;
            marker.style.left = `${displayX - 12}px`;
            marker.style.top = `${displayY - 12}px`;
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'pin-delete';
            deleteBtn.textContent = '√ó';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removePinFromImage(node, pin.id);
            });
            
            marker.appendChild(deleteBtn);
            node.appendChild(marker);
        }

        function removePinFromImage(node, pinId) {
            const pins = JSON.parse(node.dataset.pins || '[]');
            const index = pins.findIndex(p => p.id === pinId);
            
            if (index !== -1) {
                const pin = pins[index];
                pins.splice(index, 1);
                node.dataset.pins = JSON.stringify(pins);
                
                const marker = node.querySelector(`.pin-marker[data-pin-id="${pinId}"]`);
                if (marker) {
                    marker.remove();
                }
                
                const tag = promptInput.querySelector(`.pinned-image-tag[data-image-url="${node.dataset.imageUrl}"][data-pin-number="${pin.number}"]`);
                if (tag) {
                    tag.remove();
                }
            }
        }

        function updatePromptWithPins(node) {
            const pins = JSON.parse(node.dataset.pins || '[]');
            const imageUrl = node.dataset.imageUrl;
            const filename = node.dataset.filename;
            
            const existingTags = promptInput.querySelectorAll('.pinned-image-tag');
            const existingPinNumbers = new Set();
            existingTags.forEach(tag => {
                if (tag.dataset.imageUrl === imageUrl) {
                    existingPinNumbers.add(parseInt(tag.dataset.pinNumber));
                }
            });
            
            pins.forEach(pin => {
                if (!existingPinNumbers.has(pin.number)) {
                    const tag = createPinnedImageTag(imageUrl, filename, pin.number, pin.x, pin.y);
                    insertAtCursor(tag);
                }
            });
        }

        function createPinnedImageTag(imageUrl, filename, pinNumber, pinX, pinY) {
            const tag = document.createElement('span');
            tag.className = 'pinned-image-tag';
            tag.dataset.imageUrl = imageUrl;
            tag.dataset.pinNumber = pinNumber;
            tag.contentEditable = 'false';
            tag.style.userSelect = 'none';
            
            const thumbnail = document.createElement('img');
            thumbnail.src = imageUrl;
            thumbnail.style.width = '24px';
            thumbnail.style.height = '24px';
            thumbnail.style.objectFit = 'cover';
            thumbnail.style.borderRadius = '4px';
            
            const numberBadge = document.createElement('span');
            numberBadge.className = 'pin-number';
            numberBadge.textContent = pinNumber;
            
            const label = document.createElement('span');
            label.textContent = `${filename}[${pinNumber}]`;
            
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'tag-delete';
            deleteBtn.textContent = '√ó';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const node = findNodeByImageUrl(imageUrl);
                if (node) {
                    const pins = JSON.parse(node.dataset.pins || '[]');
                    const pin = pins.find(p => p.number === pinNumber);
                    if (pin) {
                        const marker = node.querySelector(`.pin-marker[data-pin-id="${pin.id}"]`);
                        if (marker) {
                            marker.remove();
                        }
                        pins.splice(pins.indexOf(pin), 1);
                        node.dataset.pins = JSON.stringify(pins);
                    }
                }
                tag.remove();
            });
            
            const tooltip = document.createElement('div');
            tooltip.className = 'image-preview-tooltip';
            
            const tooltipImg = document.createElement('img');
            tooltipImg.src = imageUrl;
            
            const pinIndicator = document.createElement('div');
            pinIndicator.className = 'pin-indicator';
            pinIndicator.textContent = pinNumber;
            
            if (pinX !== undefined && pinY !== undefined) {
                tooltipImg.onload = function() {
                    const naturalWidth = this.naturalWidth;
                    const naturalHeight = this.naturalHeight;
                    
                    const maxWidth = Math.min(window.innerWidth * 0.7, 500);
                    const maxHeight = Math.min(window.innerHeight * 0.7, 500);
                    
                    const widthRatio = maxWidth / naturalWidth;
                    const heightRatio = maxHeight / naturalHeight;
                    const scale = Math.min(widthRatio, heightRatio);
                    
                    const displayWidth = naturalWidth * scale;
                    const displayHeight = naturalHeight * scale;
                    
                    this.style.width = `${displayWidth}px`;
                    this.style.height = `${displayHeight}px`;
                    
                    const indicatorX = pinX * scale;
                    const indicatorY = pinY * scale;
                    
                    pinIndicator.style.left = `${indicatorX}px`;
                    pinIndicator.style.top = `${indicatorY}px`;
                    
                    adjustTooltipPosition(tooltip);
                };
            } else {
                tooltipImg.onload = function() {
                    const naturalWidth = this.naturalWidth;
                    const naturalHeight = this.naturalHeight;
                    
                    const maxWidth = Math.min(window.innerWidth * 0.7, 500);
                    const maxHeight = Math.min(window.innerHeight * 0.7, 500);
                    
                    const widthRatio = maxWidth / naturalWidth;
                    const heightRatio = maxHeight / naturalHeight;
                    const scale = Math.min(widthRatio, heightRatio);
                    
                    const displayWidth = naturalWidth * scale;
                    const displayHeight = naturalHeight * scale;
                    
                    this.style.width = `${displayWidth}px`;
                    this.style.height = `${displayHeight}px`;
                    
                    adjustTooltipPosition(tooltip);
                };
            }
            
            tag.addEventListener('mouseenter', () => {
                setTimeout(() => adjustTooltipPosition(tooltip), 50);
            });
            
            tooltip.appendChild(tooltipImg);
            tooltip.appendChild(pinIndicator);
            
            tag.appendChild(thumbnail);
            tag.appendChild(numberBadge);
            tag.appendChild(label);
            tag.appendChild(deleteBtn);
            tag.appendChild(tooltip);
            
            return tag;
        }

        function findNodeByImageUrl(imageUrl) {
            const nodes = imageResponseContainer.querySelectorAll('.canvas-node');
            for (let node of nodes) {
                if (node.dataset.imageUrl === imageUrl) {
                    return node;
                }
            }
            return null;
        }

        function showImageContextMenu(e, node, img) {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;
            
            const copyItem = document.createElement('div');
            copyItem.className = 'context-menu-item';
            copyItem.textContent = 'Â§çÂà∂ÂõæÁâá';
            copyItem.addEventListener('click', () => {
                if (img.src.startsWith('data:')) {
                    navigator.clipboard.writeText(img.src).then(() => {
                        console.log('ÂõæÁâáÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                    }).catch(err => {
                        console.error('Â§çÂà∂Â§±Ë¥•:', err);
                    });
                } else {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth || img.width;
                    canvas.height = img.naturalHeight || img.height;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    canvas.toBlob((blob) => {
                        navigator.clipboard.write([
                            new ClipboardItem({
                                'image/png': blob
                            })
                        ]).then(() => {
                            console.log('ÂõæÁâáÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                        }).catch(err => {
                            console.error('Â§çÂà∂Â§±Ë¥•:', err);
                        });
                    });
                }
                menu.remove();
            });
            
            const downloadItem = document.createElement('div');
            downloadItem.className = 'context-menu-item';
            downloadItem.textContent = '‰∏ãËΩΩÂõæÁâá';
            downloadItem.addEventListener('click', () => {
                const filename = node.dataset.filename || 'image.png';
                const link = document.createElement('a');
                link.href = img.src;
                link.download = filename;
                link.click();
                menu.remove();
            });
            
            const insertItem = document.createElement('div');
            insertItem.className = 'context-menu-item';
            insertItem.textContent = 'ÊèíÂÖ•Âà∞ËæìÂÖ•Ê°Ü';
            insertItem.addEventListener('click', () => {
                addCanvasImageToPrompt(node);
                menu.remove();
            });
            
            menu.appendChild(copyItem);
            menu.appendChild(downloadItem);
            menu.appendChild(insertItem);
            document.body.appendChild(menu);
            
            setTimeout(() => {
                document.addEventListener('click', (clickEvent) => {
                    if (!menu.contains(clickEvent.target)) {
                        menu.remove();
                    }
                }, { once: true });
            }, 100);
        }

        function adjustTooltipPosition(tooltip) {
            if (!tooltip) return;
            
            const rect = tooltip.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            let position = 'top';
            let offsetX = 0;
            let offsetY = 0;
            
            if (rect.top < 10) {
                position = 'bottom';
            }
            
            if (rect.left < 10) {
                offsetX = 10 - rect.left;
            } else if (rect.right > windowWidth - 10) {
                offsetX = (windowWidth - 10) - rect.right;
            }
            
            if (position === 'bottom') {
                tooltip.style.bottom = 'auto';
                tooltip.style.top = '100%';
                tooltip.style.marginBottom = '0';
                tooltip.style.marginTop = '8px';
            } else {
                tooltip.style.bottom = '100%';
                tooltip.style.top = 'auto';
                tooltip.style.marginBottom = '8px';
                tooltip.style.marginTop = '0';
            }
            
            tooltip.style.transform = `translateX(-50%) translate(${offsetX}px, ${offsetY}px)`;
        }

        imageGenMode.addEventListener('change', () => {
            console.log('Image gen mode changed:', imageGenMode.checked);
            if (imageGenMode.checked) {
                imageResponseContainer.style.display = 'block';
                responseOutput.style.display = 'none';
                console.log('Adding sample image...');
                addSampleImage();
                console.log('Sample image added');
            } else {
                imageResponseContainer.style.display = 'none';
                responseOutput.style.display = 'block';
                imageResponseContainer.innerHTML = '';
                nodeCounter = 0;
            }
        });

        temperature.addEventListener('input', () => {
            temperatureValue.textContent = temperature.value;
        });

        topP.addEventListener('input', () => {
            topPValue.textContent = topP.value;
        });

        async function testApiKey() {
            const apiKey = CONFIG.API_KEY.trim();
            
            if (!apiKey || apiKey === "YOUR_API_KEY_HERE") {
                apiStatus.innerHTML = '<span class="text-red-600">ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑ API Key</span>';
                return;
            }

            testApiKeyBtn.disabled = true;
            testLoader.classList.remove('hidden');
            apiStatus.innerHTML = '<span class="text-blue-600">Ê≠£Âú®È™åËØÅ API Key...</span>';

            try {
                const genAI = new GoogleGenerativeAI(apiKey);
                const model = genAI.getGenerativeModel({ model: CONFIG.MODEL_NAME });
                
                const result = await model.generateContent("test");
                await result.response;
                
                apiStatus.innerHTML = '<span class="text-green-600">‚úì API Key È™åËØÅÊàêÂäü</span>';
            } catch (error) {
                console.error(error);
                apiStatus.innerHTML = '<span class="text-red-600">‚úó API Key Êó†Êïà: ' + error.message + '</span>';
            } finally {
                testApiKeyBtn.disabled = false;
                testLoader.classList.add('hidden');
            }
        }

        async function saveApiKey() {
            const apiKey = CONFIG.API_KEY.trim();
            
            if (!apiKey || apiKey === "YOUR_API_KEY_HERE") {
                apiStatus.innerHTML = '<span class="text-red-600">ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑ API Key</span>';
                return;
            }

            try {
                const saveEnvResponse = await fetch('/save-env', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        apiKey: apiKey,
                        modelName: textModelName.value,
                        imageModelName: imageModelName.value
                    })
                });
                
                const saveEnvResult = await saveEnvResponse.json();
                
                if (saveEnvResult.success) {
                    const reloadEnvResponse = await fetch('/reload-env', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const reloadEnvResult = await reloadEnvResponse.json();
                    
                    if (reloadEnvResult.success) {
                        CONFIG.API_KEY = apiKey;
                        CONFIG.MODEL_NAME = textModelName.value;
                        CONFIG.IMAGE_MODEL_NAME = imageModelName.value;
                        apiStatus.innerHTML = '<span class="text-green-600">‚úì API Key Â∑≤‰øùÂ≠òÂà∞ÊúçÂä°Âô®</span>';
                    } else {
                        apiStatus.innerHTML = '<span class="text-yellow-600">‚úì API Key Â∑≤‰øùÂ≠òÔºå‰ΩÜÁéØÂ¢ÉÂèòÈáèÈáçËΩΩÂ§±Ë¥•: ' + reloadEnvResult.error + '</span>';
                    }
                } else {
                    apiStatus.innerHTML = '<span class="text-red-600">‚úó ‰øùÂ≠òÂ§±Ë¥•: ' + saveEnvResult.error + '</span>';
                }
            } catch (error) {
                console.error(error);
                apiStatus.innerHTML = '<span class="text-red-600">‚úó ‰øùÂ≠òÂ§±Ë¥•: ' + error.message + '</span>';
            }
        }

        async function clearApiKey() {
            try {
                const clearEnvResponse = await fetch('/clear-env', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const clearEnvResult = await clearEnvResponse.json();
                
                if (clearEnvResult.success) {
                    CONFIG.API_KEY = '';
                    CONFIG.MODEL_NAME = 'gemini-3-flash-preview';
                    CONFIG.IMAGE_MODEL_NAME = 'gemini-3-pro-image-preview';
                    apiKeyInput.value = '';
                    apiStatus.innerHTML = '<span class="text-green-600">‚úì API Key Â∑≤‰ªéÊúçÂä°Âô®Ê∏ÖÈô§</span>';
                } else {
                    apiStatus.innerHTML = '<span class="text-red-600">‚úó Ê∏ÖÈô§Â§±Ë¥•: ' + clearEnvResult.error + '</span>';
                }
            } catch (error) {
                console.error(error);
                apiStatus.innerHTML = '<span class="text-red-600">‚úó Ê∏ÖÈô§Â§±Ë¥•: ' + error.message + '</span>';
            }
        }

        testApiKeyBtn.addEventListener('click', testApiKey);
        document.getElementById('saveApiKeyBtn').addEventListener('click', saveApiKey);
        document.getElementById('clearApiKeyBtn').addEventListener('click', clearApiKey);

        async function callAPI() {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = promptInput.innerHTML;
            const imageTags = tempDiv.querySelectorAll('.pasted-image-item');
            imageTags.forEach(tag => tag.remove());
            
            const pinnedImageTags = tempDiv.querySelectorAll('.pinned-image-tag');
            let processedPrompt = tempDiv.textContent.trim();
            
            const pinInfo = [];
            pinnedImageTags.forEach(tag => {
                const imageUrl = tag.dataset.imageUrl;
                const pinNumber = tag.dataset.pinNumber;
                const filename = tag.querySelector('span').textContent;
                
                const node = findNodeByImageUrl(imageUrl);
                if (node) {
                    const pins = JSON.parse(node.dataset.pins || '[]');
                    const pin = pins.find(p => p.number == pinNumber);
                    if (pin) {
                        pinInfo.push({
                            imageUrl: imageUrl,
                            pinNumber: pinNumber,
                            filename: filename,
                            x: pin.x,
                            y: pin.y
                        });
                    }
                }
            });
            
            if (pinInfo.length > 0) {
                pinInfo.forEach(info => {
                    const pinTag = `[${info.pinNumber}]`;
                    if (processedPrompt.includes(pinTag)) {
                        processedPrompt = processedPrompt.replace(pinTag, `[ÂõæÁâá‰∏≠ PIN ${info.pinNumber} Ê†áËÆ∞ÁöÑ‰ΩçÁΩÆ]`);
                    }
                });
            }
            
            const prompt = processedPrompt;
            const apiKey = CONFIG.API_KEY.trim();
            const isImageGenMode = imageGenMode.checked;
            
            if (!prompt && imageDataList.length === 0 && pinInfo.length === 0) return alert("ËØ∑ËæìÂÖ•ÂÜÖÂÆπÊàñÁ≤òË¥¥ÂõæÁâá");
            if (!apiKey || apiKey === "YOUR_API_KEY_HERE") return alert("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑ API Key");

            const genAI = new GoogleGenerativeAI(apiKey);
            
            let modelName;
            if (isImageGenMode) {
                modelName = imageModelName.value;
            } else if (imageDataList.length > 0) {
                modelName = visionModelName.value;
            } else {
                modelName = textModelName.value;
            }
            
            const generationConfig = {
                temperature: parseFloat(temperature.value),
                topP: parseFloat(topP.value),
                topK: 40,
                maxOutputTokens: 8192
            };
            
            if (isImageGenMode) {
                generationConfig.imageConfig = {
                    aspectRatio: aspectRatio.value,
                    imageSize: imageSize.value
                };
            }
            
            const model = genAI.getGenerativeModel({ 
                model: modelName,
                generationConfig: generationConfig
            });

            sendBtn.disabled = true;
            loader.classList.remove('hidden');
            responseOutput.classList.remove('italic', 'text-gray-400');
            responseOutput.innerText = "Ê≠£Âú®Â§ÑÁêÜ...";
            imageResponseContainer.classList.remove('hidden');
            statusTag.innerText = "ËØ∑Ê±Ç‰∏≠";
            statusTag.className = "text-xs px-2 py-1 rounded bg-blue-50 text-blue-600";

            let loadingPlaceholder = null;
            if (isImageGenMode) {
                const aspectRatioValue = aspectRatio.value;
                const imageSizeValue = imageSize.value;
                
                let width, height;
                const baseSize = imageSizeValue === '1K' ? 1024 : imageSizeValue === '2K' ? 2048 : 4096;
                
                switch (aspectRatioValue) {
                    case '1:1':
                        width = baseSize;
                        height = baseSize;
                        break;
                    case '16:9':
                        width = baseSize;
                        height = Math.round(baseSize * 9 / 16);
                        break;
                    case '9:16':
                        width = Math.round(baseSize * 9 / 16);
                        height = baseSize;
                        break;
                    case '21:9':
                        width = baseSize;
                        height = Math.round(baseSize * 9 / 21);
                        break;
                    case '4:3':
                        width = baseSize;
                        height = Math.round(baseSize * 3 / 4);
                        break;
                    case '3:4':
                        width = Math.round(baseSize * 3 / 4);
                        height = baseSize;
                        break;
                    case '3:2':
                        width = baseSize;
                        height = Math.round(baseSize * 2 / 3);
                        break;
                    case '2:3':
                        width = Math.round(baseSize * 2 / 3);
                        height = baseSize;
                        break;
                    case '5:4':
                        width = baseSize;
                        height = Math.round(baseSize * 4 / 5);
                        break;
                    case '4:5':
                        width = Math.round(baseSize * 4 / 5);
                        height = baseSize;
                        break;
                    default:
                        width = baseSize;
                        height = Math.round(baseSize * 9 / 16);
                }
                
                const displayWidth = Math.min(width, 400);
                const displayHeight = Math.round(displayWidth * height / width);
                
                const existingNodes = imageResponseContainer.querySelectorAll('.canvas-node');
                let x = 800;
                let y = 800;
                
                if (existingNodes.length > 0) {
                    const lastNode = existingNodes[existingNodes.length - 1];
                    
                    const lastNodeX = parseInt(lastNode.style.left) || 0;
                    const lastNodeY = parseInt(lastNode.style.top) || 0;
                    const lastNodeWidth = lastNode.offsetWidth;
                    const lastNodeHeight = lastNode.offsetHeight;
                    
                    x = lastNodeX + lastNodeWidth + 50;
                    y = lastNodeY;
                    
                    if (x > 1200) {
                        x = 800;
                        y = lastNodeY + lastNodeHeight + 50;
                    }
                }
                
                loadingPlaceholder = document.createElement('div');
                loadingPlaceholder.className = 'loading-placeholder';
                loadingPlaceholder.style.width = `${displayWidth}px`;
                loadingPlaceholder.style.height = `${displayHeight}px`;
                loadingPlaceholder.style.left = `${x}px`;
                loadingPlaceholder.style.top = `${y}px`;
                
                const loadingText = document.createElement('div');
                loadingText.className = 'loading-text';
                loadingText.textContent = 'Ê≠£Âú®ÁîüÊàêÂõæÁâá...';
                
                loadingPlaceholder.appendChild(loadingText);
                imageResponseContainer.appendChild(loadingPlaceholder);
            }

            try {
                let content;
                
                if (isImageGenMode) {
                    const allImageData = [...imageDataList];
                    
                    pinInfo.forEach(info => {
                        const node = findNodeByImageUrl(info.imageUrl);
                        if (node) {
                            const img = node.querySelector('img');
                            
                            if (img.src.startsWith('data:')) {
                                const base64Data = img.src;
                                const existing = allImageData.find(data => data.data === base64Data);
                                if (!existing) {
                                    allImageData.push({
                                        data: base64Data,
                                        name: info.filename
                                    });
                                }
                            } else {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.naturalWidth || img.width;
                                canvas.height = img.naturalHeight || img.height;
                                
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                
                                const base64Data = canvas.toDataURL('image/png');
                                const existing = allImageData.find(data => data.data === base64Data);
                                if (!existing) {
                                    allImageData.push({
                                        data: base64Data,
                                        name: info.filename
                                    });
                                }
                            }
                        }
                    });
                    
                    if (allImageData.length > 0) {
                        if (prompt) {
                            content = allImageData.map(imageData => ({
                                inlineData: { 
                                    data: imageData.data.split(',')[1], 
                                    mimeType: imageData.data.split(';')[0].split(':')[1] 
                                }
                            }));
                            content.push(`${prompt}Ôºå‰ΩøÁî®${aspectRatio.value}ÂÆΩÈ´òÊØî`);
                        } else {
                            content = allImageData.map(imageData => ({
                                inlineData: { 
                                    data: imageData.data.split(',')[1], 
                                    mimeType: imageData.data.split(';')[0].split(':')[1] 
                                }
                            }));
                            content.push(`ËØ∑ÁæéÂåñËøôÂº†ÂõæÁâáÔºå‰ΩøÁî®${aspectRatio.value}ÂÆΩÈ´òÊØî`);
                        }
                    } else {
                        content = `${prompt}Ôºå‰ΩøÁî®${aspectRatio.value}ÂÆΩÈ´òÊØî`;
                    }
                } else {
                    const allImageData = [...imageDataList];
                    
                    pinInfo.forEach(info => {
                        const node = findNodeByImageUrl(info.imageUrl);
                        if (node) {
                            const img = node.querySelector('img');
                            
                            if (img.src.startsWith('data:')) {
                                const base64Data = img.src;
                                const existing = allImageData.find(data => data.data === base64Data);
                                if (!existing) {
                                    allImageData.push({
                                        data: base64Data,
                                        name: info.filename
                                    });
                                }
                            } else {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.naturalWidth || img.width;
                                canvas.height = img.naturalHeight || img.height;
                                
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                
                                const base64Data = canvas.toDataURL('image/png');
                                const existing = allImageData.find(data => data.data === base64Data);
                                if (!existing) {
                                    allImageData.push({
                                        data: base64Data,
                                        name: info.filename
                                    });
                                }
                            }
                        }
                    });
                    
                    if (allImageData.length > 0) {
                        content = allImageData.map(imageData => ({
                            inlineData: { 
                                data: imageData.data.split(',')[1], 
                                mimeType: imageData.data.split(';')[0].split(':')[1] 
                                }
                        }));
                        content.push(prompt);
                    } else {
                        content = prompt;
                    }
                }
                
                const result = await model.generateContent(content);
                const response = await result.response;
                
                if (isImageGenMode) {
                    const imagePart = response.candidates[0]?.content?.parts.find(part => part.inlineData);
                    if (imagePart) {
                        const imageData = imagePart.inlineData.data;
                        
                        const byteCharacters = atob(imageData);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'image/png' });
                        const blobUrl = URL.createObjectURL(blob);
                        
                        let filename = '';
                        let resolution = '';
                        
                        try {
                            const saveResponse = await fetch('/save-image', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ 
                                    imageData: imageData,
                                    prompt: prompt,
                                    aspectRatio: aspectRatio.value,
                                    imageSize: imageSize.value
                                })
                            });
                            const saveResult = await saveResponse.json();
                            if (saveResult.success) {
                                filename = saveResult.fileName || '';
                                statusTag.innerText = "ÊàêÂäü";
                            } else {
                                statusTag.innerText = "‰øùÂ≠òÂ§±Ë¥•";
                            }
                        } catch (saveError) {
                            console.error('‰øùÂ≠òÂõæÁâáÂ§±Ë¥•:', saveError);
                            statusTag.innerText = "‰øùÂ≠òÂ§±Ë¥•";
                        }
                        
                        const tempImg = new Image();
                        tempImg.src = blobUrl;
                        await new Promise((resolve) => {
                            tempImg.onload = () => {
                                resolution = `${tempImg.naturalWidth}x${tempImg.naturalHeight}`;
                                resolve();
                            };
                        });
                        
                        const node = createImageNode(blobUrl, prompt, nodeCounter++, filename, resolution);
                        
                        if (loadingPlaceholder) {
                            const placeholderX = parseInt(loadingPlaceholder.style.left);
                            const placeholderY = parseInt(loadingPlaceholder.style.top);
                            node.style.left = `${placeholderX}px`;
                            node.style.top = `${placeholderY}px`;
                            loadingPlaceholder.remove();
                        }
                        
                        imageResponseContainer.appendChild(node);
                        selectNode(node);
                    } else {
                        statusTag.innerText = "Êó†ÂõæÁâáÊï∞ÊçÆ";
                    }
                } else {
                    const text = response.text();
                    responseOutput.innerText = text;
                }
                
                statusTag.innerText = "ÊàêÂäü";
                statusTag.className = "text-xs px-2 py-1 rounded bg-green-50 text-green-600";
            } catch (error) {
                console.error(error);
                responseOutput.innerText = "ÂèëÁîüÈîôËØØ: " + error.message;
                statusTag.innerText = "Â§±Ë¥•";
                statusTag.className = "text-xs px-2 py-1 rounded bg-red-50 text-red-600";
                
                if (loadingPlaceholder) {
                    loadingPlaceholder.remove();
                }
            } finally {
                sendBtn.disabled = false;
                loader.classList.add('hidden');
            }
        }

        sendBtn.addEventListener('click', callAPI);

        promptInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') callAPI();
        });

        document.addEventListener('keydown', (e) => {
            if (document.activeElement === promptInput) return;
            
            if (selectedNode) {
                const step = 10;
                const currentLeft = parseInt(selectedNode.style.left) || 0;
                const currentTop = parseInt(selectedNode.style.top) || 0;
                
                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        selectedNode.style.top = `${currentTop - step}px`;
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        selectedNode.style.top = `${currentTop + step}px`;
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        selectedNode.style.left = `${currentLeft - step}px`;
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        selectedNode.style.left = `${currentLeft + step}px`;
                        break;
                }
            }
        });

        window.addEventListener('load', () => {
            setTimeout(initCanvas, 100);
        });
    </script>
</body>
</html>